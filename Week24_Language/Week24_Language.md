# Week 24 - Language(C, C++, C#)

1. **C++ Virtual 키워드**

   > 오버라이딩을 성립할 수 있게 해주어 다형성을 구현하는 핵심 역할을 해준다

   - C++에서 가상함수는 파생 클래스에서 재정의할 것으로 기대하는 멤버 함수를 의미한다
   - 자신을 호출하는 객체의 동적 타입에 따라 실제 호출할 함수가 결정된다
   > 정적 바인딩 : 함수를 호출하는 코드는 컴파일 타임에 고정된 메모리 주소로 변환
   > 동적 바인딩 : 컴파일 타임이 아닌, 프로그램이 실행될 때 객체를 결졍하여 런 타임에 올바른 함수가 실행될 수 있도록 함

   - **가상 함수 테이블(vtbl)** : 해당 클래스의 객체들을 위해 선언된 가상 함수들의 주소를 저장
   - **가상 소멸자** : 기초 클래스의 소멸자는 반드시 가상으로 선언해야 한다. 파생 클래스의 메모리가 해제되지 않을 수 있기 때문 

2. **C++ 가상함수의 원리**

    > vptr을 통한 주소 참조 -> 그 주소의 vtable 조사 -> 호출한 함수 이름에 맞는 가상함수 호출

    - 가상함수는 vptr과 vtable을 만들어야 되기 때문에 속도가 지연된다
    - 지연되는 속도가 프로그램에 심각한 영향을 끼칠 정도는 아니고 단점보다 장점이 훨씬 커 많이 사용한다

3. **Vector와 Array의 차이점**
    - Vector 
        - 크기가 동적
        - 삽입, 삭제 비용이 가볍다
    - Array
        - 크기가 고정적
        - 삽입, 삭제 비용이 크다

4. **C#의 generic과 C++의 template의 차이점**
    - 공통점 : 둘 다 매개변수가 있는 형식을 지원하는 기능을 갖고있음
    - 차이점
        - C++ 템플릿은 사용하지 않으면 컴파일 하지 않는다. 즉 컴파일이 1번 일어남
        - C# 제네릭은 사용하지 않더라도 그에 관련된 정보를 저장하기 위해 메타데이터가 생겨난다. 즉, 컴파일이 2번 일어남

5. **C#의 박싱과 언박싱**
    - 박싱 : 값 타입(Value Type)의 객체를 참조 타입(Reference Type)로 변환하는 작업을 말한다
    - 언박싱 : 참조 타입을 값 타입으로 변환하는 작업을 말한다

6. **얕은 복사와 깊은 복사**
    - 얕은 복사 : 아주 최소한의 복사. 인스턴스가 메모리에 새로 생기지 않고, 주소값을 복사하여 같은 메모리를 가리킴
    - 깊은 복사 : 데이터 자체를 통째로 복사한다. 복사된 두 객체는 완전히 독립적인 메모리를 차지한다.

7. **new와 malloc**
    |특징|new/delete|malloc/free|
    |표면적인 차이|연산자|함수|
    |할당된 메모리|dynamic memory|heap|
    |반환 값|해당 타입의 포인터|void *|
    |실패|Throw(null 리턴 X)|null|
    |배열|컴파일러에 의해 계산|특정 숫자로 지정해줘야 함|
    |재할당|복사 생성자로 인해 재할당은 delete 후에 다시 new로 할당|realloc으로 재할당|
    |재정의|사용자에 의해 new/delete 정의|malloc/free는 재정의 불가|
    |Overload|operator라서 가능|function이라 불가능|

8. **C, C++, C# 비교**
    - C : 절차지향적 언어. 속도가 빠르다. 가비지 콜렉션이 없다
    - C++ : 객체지향 프로그래밍 언어. 함수형 프로그래밍 지원. 속도가 빠르다. 가비지 콜렉션이 없다
    - C# : Java와 비슷. 객체지향 프로그래밍 언어. 가비지 콜렉션을 지원한다. new는 존재하지만 delete는 없다
