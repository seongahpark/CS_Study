# Week 29 - Unity

1. **렌더링 파이프라인**

    > 씬(Scene)의 콘텐츠를 가져와 화면에 표시하는 작업 수행
    >
    > 3D 세계에 대한 기하학적 표현과 세계를 바라보는 관점을 정의하는 가상 카메라를 이용하여 2D 이미지를 만들어낸다

    #### 작업 종류

    - 컬링 : 오클루전 컬링. 유니티가 다른 게임 오브젝트에 의해 뷰에서 가려진 게임 오브젝트에 대한 렌더링 계산을 수행하지 못하도록 함
    - 렌더링 : 3차원 공간에 위치한 물체를 모니터 화면으로 그려내는 작업
    - 포스트 프로세싱 : 기존에 렌더링 된 씬에 렌더링 효과를 더하는 작업. 기존 콘텐츠를 수정할 필요 없이 시각적인 효과를 즉시 구현 가능

2. **최적화 전략 수립 과정**

    > 코드 최적화, 리소스 최적화, 오디오 최적화 등이 있다

    #### 코드 최적화

    - 유니티 객체들은 변수에 저장하여 캐싱해서 사용하는 것이 좋다
    - FindObject 계열 함수는 느리므로, 미리 찾아서 캐싱해야 한다
    - Instantiate와 Destroy 함수를 이용한 프리팹의 생성/해제는 비용이 크므로 활성/비활성을 활용하는 **오브젝트 풀링** 방식 사용
    - Update 함수 보다는 Coroutine 활용
    - 나눗셈 보다는 곱셈이 몇 십배는 빠르다
    - 박싱과 언박싱은 부하가 큰 작업이다
    - magnitude 보다는 sqrMagnitude를 사용해서 비교하여 제곱근 계산을 피한다
    - 삼각함수의 값은 상수로 저장하고 사용하는 것이 좋다
    - 문자열은 readonly나 const로 지정하여 가비지 컬렉션으로부터 벗어나도록 한다
    - Garbage Collector
        - Mono의 동적 메모리 관리 때문에, 메모리 해제를 위해 GC가 자동 호출 됨
        - GC가 언제 일어날지 모르며, 일어나게 된다면 게임이 멈추는 렉 현상이 발생한다
        - 동적 메모리 해제가 가능한 일어나지 않도록 하는 것이 GC 관리의 핵심
    - 문자열 병합은 StringBuilder 함수를 사용하여 병합
    - 일반 array에 한해 foreach보다는 for문 사용을 권장
        - foreach는 한 번 돌때마다 24byte의 쓰레기 매모리 생성
    - 태그 비교에는 compareTag()를 사용한다
        - `if(go.tag == "enemy")` 처럼 사용하면 객체의 tag 프로퍼티를 호출하므로 추가 메모리를 할당하고 복사하기 때문
    - 데이터 타입에서 Class 대신 구조체를 사용한다
        - 구조체는 GC에 들어가지 않는다. Stack에 할당되기 때문
    - 임시 객체들을 만들어내는 API를 조심한다
        - ex) GetComponents<T>, Mesh.Vertices, Camera.allCameras ...
    - 빈 콜백 함수는 제거한다
        - Start()나 Update()와 같은 콜백함수는 비어있어도 성능에 영향을 끼친다
    
    #### 리소스 최적화

    - 권장 압축 텍스쳐 사용
    - 텍스처의 사이즈는 무조건 2의 제곱이어야 한다
    - 텍스처 아틀라스를 활용하라
        - UI뿐만 아니라 같은 재질의 오브젝트들을 묶음
    - 압축된 텍스처와 밉맵을 사용하자

    #### 오디오 최적화

    - 모바일에서는 스테레오는 의미 없다
    - 압축 사운드와 비압축 사은두 구별
        - 비압축 사운드 : 순간적인 효과음, 이펙트 등 (wav)
        - 압축 사운드 : 배경음악 (mp3, ogg)

3. **코루틴과 비동기**

    > 코루틴을 사용하면 작업을 다수의 프레임에 분산할 수 있다

    - yield를 통해 제어권을 다시 유니티로 넘겨서 실행하는 방식
    - 코루틴은 동기식
    - 코루틴은 스레드가 아니다. 코루틴의 동기 작업은 메인 스레드에서 실행된다
    - 비동기는 요청한 그 자리에서 결과가 주어지는 것이 아님

4. **스크립트 실행 순서**

    - 기본적으로 Awake, OnEnable, Update 함수는 스크립트가 로딩되는 순서대로 호출된다
    - 이 순서를 `Script Execution Order` 설정을 이용하여 수정 가능하다

5. **Fake null**

    > Unity Object의 == 또는 != 연산에서 null을 비교했을 때, System.Object의 null을 비교했을 때 값이 다르게 나오는 현상

    - Unity Object의 경우 C++ 네이티브 객체를 래핑하여 사용하는데, Destroy 할 경우 래핑한 객체는 삭제되지만, Unity Object는 GC에서 메모리를 해제하기 전 까지 남아 있어 해당 현상이 발생
    - 완벽하게 null 처리 하려면? -> **null로 변경 이후 Destroy하면 System Object도 null 처리가 됨**

6. **virtual, abstract, interface**

    - Virtual : 하나의 기능을 하는 완전한 클래스. 파생 클래스에서 상속하여 추가적인 기능 추가 및 virtual 한정자가 달린 것을 재정의하여 사용 가능
    - Abstract : 여러 개의 파생 클래스에서 공유할 기본 클래스의 공통적인 정의만 하고, 파생클래스에서 abstract 한정자가 달린 것은 모두 재정의를 필수로 해야 한다. 개념적으로 계층적인 구조에서 사용 (ex. 동물, 사물과 같은 계층적인 구조)
    - Interface : abstract와 비슷하지만, 멤버 변수 사용이 불가하다. 서로 다른 게층이나 타입이라도 같은 기능을 추가하고 싶을 떄 사용 (ex. 사람이나 기계가 말하게 하는 인터페이스 추가)