# Week 8 - 질문 정리

- 경림

  - 페이지 교체에서 어떤 오버헤드가 발생할 수 있는가? 왜 오버헤드가 발생하는가?

    - 이런 오버헤드를 줄이기 위한 방법
  - 순차접근과 직접접근에 대해 설명
    - 데이터베이스에서 활용되는 방법은 무엇일까?

- 성아

  - 메모리 관리 장치(MMU)의 역할을 말해보시오
    - MMU의 메모리 보호 방법 설명
    - Base와 Limit 레지스터를 활용한 메모리 보호 기법도 아는가
  - 파일 시스템의 접근 방법에 대해 설명
    - 파일 시스템의 목적
    
    - 파일과 폴더를 구분하는 방법
    
      > 파일인지 디렉터리인지 구분해줄 수 있는 비트로 구분
      >
      > 파일이면 0, 폴더면 1 이런식으로

  

- 성진

  - MMU에 대해 설명
  - 페이지 교체 시, 오버헤드를 감소시킬 수 있는 방법
  - 파일 시스템의 특징 설명
  - 파일시스템의 두가지 영역에 대해 설명
  - 트리 구조 디렉터리에 대해 설명
  
  
  
- 현준

  - 메모리 할당 기법 (Memory Allocation)은 무엇이 있는가?

    - 연속 할당 : 프로세스를 하나의 연속된 메모리 공간에 할당하는 정책

      > **멀티 프로그래밍에서의 연속 할당 기법**
      >
      > 1. FPM (고정분할) : 메모리 공간을 고정된 크기로 분할, 하나의 파티션에는 하나의 프로세스만 적재. 각 파티션의 경계는 Boundary Address Register로 보호
      > 2. VPM (가변분할) : 프로세스를 처리하는 과정에서 메모리 공간을 동적으로 분할

    - 비연속 할당 : 사용자 프로그램을 여러 개의 block으로 분할하고 실행 시 필요한 block들만 메모리에 적재. 나머지 block들은 swap device (disk)에 존재

    - 연속 할당의 장단점 : 오버헤드를 발생시키지 않지만 메모리 낭비를 증가시킴

    - 비연속 할당의 장단점 : 주소 변환의 오버헤드를 발생시키고, 프로세스의 실행 속도를 감소시키지만 메모리 사용을 증가시킴

  - Cache Memory에 대해 설명

    > 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치.
    >
    > CPU와 주기억장치의 속도 차이로 성능 저하를 방지하기 위한 방법

    - 지역성(Locality)에 대해 예시와 함께 설명

      > 1. 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에도 참조되는 특성
      > 2. 공간 지역성 : 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성

  - 디렉터리 구조에 대해 설명

    > 1. Flat Directory Structure (1단계 디렉터리)
    > 2. 2-Level Directory Structure (2단계 디렉터리)
    > 3. Hierarchial Directory Structure (트리 구조 디렉터리)

  - 디스크의 빈 공간을 관리하기 위한 기법 중 한 가지 설명

    > Free Space Management를 설명하면 됨

---

#### 더 공부해볼 것

- **Free Space Management** (프리 스페이스 매니지먼트)

  > 디스크 공간은 제한되어 있기 때문에 삭제된 파일들의 공간을 새로운 파일들을 위해 다시 사용해야 함
  >
  > - 디스크 공간의 빈 트랙을 보존하기 위해 시스템은 빈 공간 리스트를 유지
  > - 빈 공간 리스트에 비어 있는 모든 디스크의 블록들 등록
  > - 새로운 파일 생성을 위해 빈 공간 리스트 탐색 후 할당
  > - 할당된 공간은 빈 공간 리스트에서 삭제
  > - 파일이 삭제되면 다시 빈 공간 리스트에 추가

  > 1. Bit Vector
  >
  >    > 빈 공간 리스트는 비트맵 또는 비트 벡터로 구현
  >    >
  >    > 블록이 비어 있으면 0, 블록이 할당 되어 있으면 1
  >    >
  >    > 장점 : 액세스가 간편, 디스크 내 연속적인 n개의 빈 블록을 찾는데 효과적
  >    >
  >    > 단점 : 전체 벡터 대부분이 액세스를 위해 메인 메모리에 존재하지 않으면 비효율적 (대형 컴퓨터보다 마이크로 컴퓨터에 알맞음)
  >
  > 2. Linked List
  >
  >    > 모든 빈 디스크 블록들을 연결
  >    >
  >    > 첫 번째 빈 블록 안에 다음 빈 블록의 포인터를 갖고 있도록 구현
  >    >
  >    > 장점 : 구조가 간단, 외부 단편화 발생 X
  >    >
  >    > 단점 : 리스트를 탐색하는데 있어 각 블록을 모두 읽기 때문에 비효율적 -> 실질적인 입출력이 필요
  >
  > 3. Grouping (Index Block)
  >
  >    > 빈 리스트 액세스가 변경된 것
  >    >
  >    > 첫 번째 빈 블록 내에 n개의 빈 블록들의 번지 저장
  >    >
  >    > 처음 n-1개는 실제로 비어있고 마지막 한 개는 다른 n개의 빈 블록을 주소를 포함하고 있는 다른 블록의 디스크 주소를 포함
  >    >
  >    > 장점 : 다수 개의 사용 가능 블록들의 주소를 쉽게 찾을 수 있음 (직접 접근에 효율적)
  >    >
  >    > 단점 : 공간 오버헤드 발생 가능, 인덱스 블록 크기에 따라 파일의 최대 크기가 제한
  >
  > 4. Counting (계수)
  >
  >    > 연속된 빈 블록 중에서 첫 번째 빈 블록의 주소와 해당 블록 이후로의 빈 블록의 개수를 Count라는 변수에 저장하여 관리
  >    >
  >    > 몇 번째 블록 뒤로는 빈 공간이 몇 개가 있다는 식

---

**다음주 주제** - **Data Structure 시작**

> **배열**
>
> **연결 리스트**
>
> **Array & ArrayList & LinkedList**
>
> **스택 & 큐**
>
> **힙(Heap)**

