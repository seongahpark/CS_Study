# Week 8 - Operating System

[출처 : gyoogle](https://gyoogle.dev/blog/computer-science/operating-system/Memory.html)

### 목차

[1. 메모리 (Memory)](#메모리-(Memory))

[2. 파일 시스템 (File System)](#파일-시스템-(File-System))



---

<br>

## 메모리 (Memory)

### 메인 메모리 (Main Memory)

> CPU가 직접 접근할 수 있는 기억장치
>
> 프로세스가 실행되려면 프로그램이 메모리에 올라와야 함

- 주소가 할당된 일련의 바이트들로 구성



#### 메모리 관리 장치 (MMU)

- CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품

- 가상 메모리 주소를 실제 메모리 주소로 변환, 메모리 보호, 캐시 관리, 버스 중재 등의 역할

- ``가상 주소`` : 프로그램 상에서 사용자가 보는 주소 공간

- MMU의 메모리 보호

  > 프로세스는 독립적인 메모리 공간을 갖고, 자신의 공간만 접근해야 함
  >
  > 한 프로세스에게 합법적인 주소 영역을 설정하고, 잘못된 접근이 오면 trap을 발생시켜 보호

  - base와 limit 레지스터를 활용한 메모리 보호 기법

    > base 레지스터 : 메모리상의 프로세스 시작수로를 물리 주소로 저장
    >
    > limit 레지스터 : 프로세스의 사이즈 저장
    >
    > 프로세스의  접근 가능한 합법적 메모리 영역 x : ```base <= x < base + limit```
    >
    > 이 영역 밖에서 접근 요구시 trap 발생
    >
    > 안전성을 위해 base와 limit 레지스터는 **커널 모드**에서만 수정 가능하도록 설계 -> 사용자 모드에서는 직접 변경 X

- **메모리 과할당 (Over Allocating)**

  > 실제 메모리 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황
  >
  > ※ 예시 
  >
  > 1. 프로세스 실행 도중 페이지 폴트 발생
  > 2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
  > 3. 메모리의 빈 프레임에 페이지를 올려야 하는데, 모든 메모리가 사용중이라 빈 프레임이 없음

  - 과할당 해결 방법 -> 빈 프레임 확보

    > 1. 메모리에 올라와 있는 한 프로세스를 종료시켜 빈 프레임 얻음
    > 2. 프로세스 하나를 swap out 후, 이 공간을 빈 프레임으로 활용 (권장)

    1번 방법은 사용자에게 페이징 시스템을 들킬 가능성이 높아 하면 안됨

    페이징 기법은 사용자 모르게 시스템 능률을 높이기 위해 선택한 일이므로 들키지 않게 처리

- **페이지 교체**

  > 메모리 과할당 발생 시, 프로세스 하나를 swap out하여 빈 프레임 확보

  1. 프로세스 실행 도중 페이지 폴트 발생
  2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
  3. 메모리에 빈 프레임 있는지 확인 -> 있으면 해당 프레임 사용, 없으면 victim 프레임 선정 후 디스크에 기록하고 페이지 테이블 업데이트
  4. 빈 프레임에 페이지 폴트가 발생한 페이지를 올린 후 페이지 테이블 업데이트

  페이지 교체가 이루어지면 아무일이 없던 것 처럼 프로세스를 계속 수행시켜 사용자가 알지 못하도록 처리

  페이지 교체 당시 오버헤드를 최대한 줄여야 사용자가 알지 못한다

  - 오버헤드 감소 방법

    > 오버헤드 원인 : 빈 프레임이 없을 시 victim 프레임을 비울 때와 원하는 페이지를 프레임으로 올리면서 두 번의 디스크 접근, 입출력 연산이 일어나는데, 이 연산이 많이 일어나면 오버헤드가 발생함

    1. 변경비트를 모든 페이지마다 둬서,  victim 페이지가 정해지면 해당 페이지의 비트 확인

       > **해당 비트가 set 상태** : 해당 페이지 내용이 디스크 상의 페이지 내용과 달라졌다(수정)는 뜻이므로 디스크에 기록해야 함
       >
       > **bit가 clear 상태** : 디스크 상의 페이지 내용과 메모리 상의 페이지가 정확히 일치하는 상황. 즉, 디스크에 기록할 필요 X

    2. 페이지 폴트가 발생할 확률을 줄이는 페이지 교체 알고리즘 선택



### 캐시 메모리

> 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치
>
> CPU와 주기억장치의 속도 차이로 성능 저하를 방지하기 위한 방법

- CPU가 이미 봤던걸 재접근 할 때, 메모리 참조 및 인출 과정에 대한 비용을 줄이기 위해 캐시에 저장해둔 메모리 활용

- 캐시는 플리플롭 소자로 구성된 SRAM이므로 DRAM보다 빠름

- **CPU와 기억장치의 상호작용**

  : CPU에서 주소 전달 -> 캐시 기억장치에 명령이 존재하는지 확인

  > 존재 (Hit) : 해당 명령어를 CPU로 전송 -> 완료
  >
  > 비존재 (Miss) : 명령어를 갖고 주기억장치로 접근 -> 해당 명령어를 가진 데이터 인출 -> 해당 명령어 데이터를 캐시에 저장 -> 해당 명령어를 CPU로 전송 -> 완료

- **지역성**

  > CPU가 어떤 데이터를 원할지 예측하여 적중률을 높여야하는데 이 때 사용되는 것이 ``지역성의 원리``
  >
  > 기억 장치 내의 정보를 균일하게 액세스 하는 것이 아니라 한 순간에 특정 부분을 집중적으로 참조

  - 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에도 참조되는 특성
  - 공간 지역성 : 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성

- **캐싱 라인**

  > 캐시에 데이터를 저장할 시, 자료구조를 활용해 묶어서 저장하는 방법
  >
  > 캐시에 저장하는 데이터에 데이터의 메모리 주소를 함께 저장하여 빠르게 원하는 정보를 찾을 수 있음 (set, map 활용)

  - 캐시에 목적 데이터가 저장되어있을 때 바로 접근하여 출력할 수 있도록 만들기 위해 사용

<br>

<br>

---

<br>

## 파일 시스템 (File System)

> 컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록 유지 및 관리하는 방법

1. 특징
   - 커널 영역에서 동작
   - 파일 CRUD (Create, Read, Update, Delete) 기능을 원활히 수행하기 위한 목적
   - 계층적 디렉터리 구조를 가짐
   - 디스크 파티션 별로 하나씩 둘 수 있음
2. 역할
   - 파일 관리
   - 보조 저장소 관리
   - 파일 무결성 메커니즘
   - 접근 방법 제공
3. 개발 목적
   - 하드디스크와 메인 메모리 속도차를 줄이기 위함
   - 파일 관리
   - 하드디스크 용량 효율적 이용
4. 구조
   - 메타 영역 : 데이터 영역에 기록된 파일 이름, 위치, 크기, 시간 정보, 삭제유무 등의 파일 정보
   - 데이터 영역 : 파일의 데이터



#### 접근 방법

1. **순차 접근 (Sequential Access)**

   > 가장 간단한 접근 방법, 대부분 연산은 read와 write

   ![img](https://noep.github.io/2016/02/23/10th-filesystem/10.1.png)

   - 현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read와 write 진행
   - 뒤로 돌아갈 땐 지정한 offset만큼 되감기
   - 테이프 모델 기반

   

2. **직접 접근 (Direct Access)**

   > 특별한 순서 없이, 빠르게 레코드를 read, write 가능

   ![img](https://noep.github.io/2016/02/23/10th-filesystem/10.2.png)

   - 현재 위치를 가리키는 cp 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현 가능
   - 무작위 파일 블록에 대한 임의 접근 허용. 즉, 순서의 제약 X
   - 대규모 정보를 접근할 때 유용. 데이터베이스에 활용

   

3. **기타 접근**

   > 직접 접근 파일에 기반하여 색인 구축

   ![img](https://noep.github.io/2016/02/23/10th-filesystem/10.3.png)

   - 크기가 큰 파일을 입출력 탐색할 수 있게 도와주는 방법



### 디렉터리와 디스크 구조

- **1단계 디렉터리 (Flat / Single-Level Directory Structure)**

  > 가장 간단한 구조

  - 파일들은 서로 유일한 이름을 가짐
  - 서로 다른 사용자라도 같은 이름 사용 불가

  ![img](https://noep.github.io/2016/02/23/10th-filesystem/10.5.png)

- **2단계 디렉터리 (2-Level Directory Structure)**

  > 사용자에게 개별적인 디렉터리 생성

  - UFD : 자신만의 사용자 파일 디렉터리
  - MFD : 사용자의 이름과 계정번호로 색인되어 있는 디렉터리

  ![img](https://noep.github.io/2016/02/23/10th-filesystem/10.6.png)

- **트리 구조 디렉터리**

  > 2단계 구조에서 확장된 다단계 트리 구조

  - 한 비트를 활용하여, 일반 파일(0)인지 디렉터리 파일(1)인지 구분

  <img src="https://noep.github.io/2016/02/23/10th-filesystem/10.7.png" alt="img" style="zoom:80%;" />

- **그래프 구조 디렉터리**

  > 순환이 발생하지 않도록 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나, 가비지 컬렉션을 이용해 전체 파일 시스템을 순회하고 접근 가능한 모든 것을 표시

  - 링크가 있으면 우회하여 순환을 피할 수 있음

  <img src="https://noep.github.io/2016/02/23/10th-filesystem/10.9.png" alt="img" style="zoom:80%;" />

