# Week 31 - Unrealengine

1. **PlayerController & Pawn**

    > PlayerController는 Pawn과 플레이어 사이의 인터페이스 = 플레이어의 의지

    - Controller 클래스를 상속받는다
        - Possess() 함수로 Pawn 제어권 획득
        - UnPossess() 함수로 제어권 포기
    - 기본적으로 자신의 빙의(Possess)하여 컨트롤하는 폰을 레퍼런스로 가지고 있게 된다
    - 디폴트 폰을 None이 아닌 특정 폰으로 설정해둔다면, 게임 시작시 폰이 생성되고 플레이어 컨트롤러는 생성된 폰에 자동으로 빙의됨

2. **GameMode & GameState**

    > 플레이어 중인 게임의 정보를 처리하는 클래스

    #### GameMode

    - 게임 플레이시 필요한 규칙이 정의된 클래스
    - 게임 규칙이 어떻게 되냐에 따라 정의와 구현이 변경됨
    - 서버에만 존재 (보안상의 이슈를 위함)
    
    #### GameState

    - 클라이언트가 필요한 정보를 서버에서 가져오기 위한 소통
    - 클라이언트가 게임의 상태를 모니터링 할 수 있도록 해줌
    - ex) 접속된 플레이어 목록, 팀 점수, 완료한 미션 등

3. **PlayerState**

    > 인간 플레이어 or 플레이어인 척 하는 봇과 같은 게임 참여자의 상태

    - 일반적으로 AI에는 PlayerState가 없지만, 플레이어를 대체할 수 있는 경우에는 가질 수 있다
    - 모든 플레이어에 대한 PlayerState는 모든 머신에 존재하며, 동기화 상태 유지를 위해 자유로이 리플리케이트 간으
        - PlayerController는 모든 머신에 존재하는 것은 아니다
    - ex) 플레이어 이름, 점수, 대전상대 레벨 등

4. **UFunction**

    > 리플렉션을 위한 매크로

    #### 자주 사용하는 키워드

    - BlueprintCallable :  C++에서 작성한 함수를 블루프린트에서 사용할 수 있게 하는 키워드. 블루프린트 내에서 재정의 불가능
    - BlueprintPure : readonly, 값 하나 반환하는 형태에 사용하는 함수 형태
    - BlueprintImplementableEvent : C++에서 블루프린트 함수를 호출하기 위한 함수
    - BlueprintNativeEvent : C++ 에서 사용하는 가상 함수와 비슷한 개념

5. **World & Level**

    #### World

    - 월드는 최상위 레벨 오브젝트
    - 렌더링 될 액터와, 컴포넌트를 대표하는 오브젝트(UObject)
    - 여러가지 레벨들을 World Composition으로 정리하여 사용할 수 있다

    #### Level

    - 모든 게임 오브젝트들은 레벨 속에 존재
    - 스태틱 메시, 볼륨, 라이트, 블루프린트 등으로 이루어짐
    - 기본적으로는 레벨 그 자체를 말하는 Persistent Level이 하나 존재하며, 그 아래에 여러 서브 레벨들이 존재할 수 있다

    #### Sub Level

    - 레벨은 바이너리 에셋
    - 서브 레벨을 통해 여러 명이 같은 게임 공간을 동시에 작업 가능하다

    #### Streaming Level

    - 월드의 부분 부분을 나눠 노드에서 사용하게 하는 것
    - 큰 레벨이 있을 때 레벨에 대한 데이터들이 퍼지는 형태, 메모리를 과다하게 잡아먹어 오버헤드가 심해지는 것을 방지하기 위함

    #### World vs Level

    - 월드는 하나만 존재. 게임상태에 해당
    - 레벨은 분리 가능

6. **Code Standard for UE**

    > 협업을 위한 코드 포맷을 준수하는 것을 의미

    - 대괄호는 반드시 준수
    - 탭은 실행 블록 별로 코드 들여쓰기
    - SWITCH는 다음 케이스로 넘어가는지 명시적으로 밝힐 것
    - 읽는 사람을 염두에 두고 클래스 체계를 작성
    - 클래스에서 public을 먼저 선언하고, 뒤에 클래스의 private 구현