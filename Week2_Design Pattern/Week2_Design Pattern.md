

# Week2 - Design Pattern

[출처 : gyoogle](https://github.com/gyoogle/tech-interview-for-developer)

## Design Pattern

##### 개요

> **SW 재사용성, 호환성, 유지 보수성을 위한 일종의 설계 기법**
>
> 유지 보수시  발생하는 문제 해결을 예방하기 위해 만든 패턴

> **SOLID 객체지향 설계 원칙**
>
> ```c
> 1. SRP (Single Responsibility Principle)
>  - 하나의 클래스는 하나의 역할만 해야 함
> 2. OCP (Open - Close Principle)
>  - 확장(상속)에는 열려있고, 수정에는 닫혀 있어야 함
> 3. LSP (Liskov Substitution Principle)
>  - 자식이 부모의 자리에 항상 교체될 수 있어야 함
> 4. ISP (Interface Segregation Principle)
>  - 인터페이스가 잘 분리되어, 클래스가 꼭 필요한 인터페이스만 구현하도록 해야 함
> 5. DIP (Dependency Inversion Property)
>  - 상위 모듈이 하위 모듈에 의존하면 안됨. 둘 다 추상화에 의존하며, 추상화는 세부 사항에 의존하면 안됨
> ```

> **분류**
>
> 1. 생성 패턴 (Creational) : 객체의 **생성 방식** 결정
>
>    ```
>    ex) DBConnection을 관리하는 Instance를 하나만 만들 수 있도록 제한
>    ```
>
> 2. 구조 패턴 (Structural) : 객체간의 **관계**를 조직
>
>    ```
>    ex) 2개의 인터페이스가 서로 호환이 되지 않을 때, 연결해주기 위해 새로운 클래스를 만들어 연결시킴
>    ```
>
> 3. 행위 패턴 (Behavioral) : 객체의 **행위**를 조직, 관리, 연합
>
>    ```
>    ex) 하위 클래스에서 구현해야 하는 함수 및 알고리즘들을 미리 선언, 상속시 이를 필수로 구현
>    ```

#### 어댑터 패턴

>- 용도 : 클래스를 바로 사용할 수 없는 경우(다른 곳에서 개발, 수정할 수 없을 때) 중간에서 변환 역할을 해줄 클래스를 만들기 위함
>- 사용 방법 : 상속
>- 호환되지 않은 인터페이스를 사용하는 클라이언트 그대로 활용 가능
>- 향후 인터페이스가 바뀌더라도, 변경 내역은 어댑터에 캡슐화 되므로 클라이언트가 바뀔 필요 X

#### 싱글톤 패턴

>- 애플리케이션이 시작될 때, 하나의 인스턴스만 생성(static)하여 사용하는 디자인 패턴
>- 객체를 생성할 때 마다 메모리 영역을 할당받아야 하지만, 한 번의 new를 통해 객체를 생성한다면 메모리 낭비 방지
>- 전역 인스턴스이므로 다른 클래스의 인스턴스들이 데이터를 공유하는 것이 가능
>- 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 주로 사용 (유니티 - 게임매니저)
>- 단점은 OCP 위배, 싱글톤 인스턴스가 혼자 너무 많은 일을 하거나, 많은 데이터를 공유할 경우 결합도가 높아지는 문제와 멀티 스레드 환경에서 동기화 처리를 하지 않을 때 인스턴스가 2개 생성되는 문제 발생
>- 실무에서는 싱글톤은 지양

#### 탬플릿 메소드 패턴

>- 특정 환경 or 상황에 맞게 확장, 변경할 때 유용한 패턴
>
>- > 추상 클래스 : 메인이 되는 로직 부분은 일반 메소드로 선언
>  >
>  > 구현 클래스 : 메소드를 선언 후 호출
>
>- 장점 : 구현 클래스에서는 추상 클래스에 선언된 메소드만 사용하므로, 핵심 로직 관리가 용이, 객체 추가 및 확장 가능
>
>- 단점 : 추상 메소드가 많아지면, 클래스 관리가 복잡

#### 팩토리 메소드 패턴

>- 객체를 만드는 부분을 Sub Class에 맡기는 패턴
>
>  >Robot (추상 클래스)
>  >
>  >ㄴ SuperRobot
>  >
>  >ㄴ PowerRobot
>  >
>  >RobotFactory (추상 클래스)
>  >
>  >ㄴ SuperRobotFactory
>  >
>  >ㄴ ModifiedSuperRobotFactory
>
>- Robot이라는 클래스를 RobotFactory에서 생성

#### 옵저버 패턴

>- 상태를 가지고 있는 주체 객체와 상태의 변경을 알아야 하는 관찰 객체로 구성
>- 객체들의 규모가 커 복잡성이 큰 경우에 사용
>- 한 객체의 상태가 바뀜 -> 그 객체에 의존하는 다른 객체들에게 연락이 감 -> 자동으로 정보가 갱신되는 1:N (또는 1:1) 관계

#### 스트레티지 패턴

>- 어떤 동작을 하는 로직을 정의한 후, 이것들을 하나로 묶어 (캡슐화) 관리하는 패턴
>- 새로운 로직을 추가하거나 변경시, 한번에 효율적으로 변경 가능

#### 컴포넌트 패턴

>- 유니티는 컴포넌트 구조 사용
>- 로직을 기능별로 컴포넌트화 함
>- 캡슐화를 살려주는 장점

#### MVC 패턴

>- Model, View, Controller 의 약자
>
>- 모델 : 애플리케이션의 정보, 데이터
>
>- 뷰 : 사용자 인터페이스 요소
>
>- 컨트롤러 : 데이터와 사용자 인터페이스 요소들을 잇는 이벤트들을 처리하는 역할
>
>  <img src="https://mblogthumb-phinf.pstatic.net/MjAxNzAzMjVfMjIg/MDAxNDkwNDM4ODMzNjI2.nzDNB5K0LuyP4joE2C4rIbL5Ue2F3at7wiI6ZpuTJN0g.WZ6V-WHZygLYW2WSdzcs7uAiAWgAJe3_H0XdkYKkutkg.PNG.jhc9639/1262.png?type=w800" alt="img" style="zoom:60%;" />
>
>  ​										출처 : 오픈듀토리얼스

