# Week 23 - 질문 정리

[출처 - Gyoogle Interview 중 Network](https://gyoogle.dev/blog/interview/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.html)

1. **OSI 7계층을 설명하시오**

   > 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약

   - 1계층, 물리 : 전송하는데 필요한 기능을 제공 (통신 케이블, 허브)
- 2계층, 데이터 링크 : 송/수신 확인, MAC 주소를 가지고 통신함 (브릿지, 스위치)
   - 3계층, 네트워크 : 패킷을 네트워크 간의 IP를 통해 데이터 전달 (라우팅)
   - 4계층, 전송 : 두 host 시스템으로부터 발생하는 데이터 흐름 제공
   - 5계층, 세션 : 통신 시스템 사용자간의 연결을 유지 및 설정
   - 6계층, 표현 : 세션 계층 간의 주고받는 인터페이스를 일관성있게 제공
   - 7계층, 응용 : 사용자가 네트워크에 접근할 수 있도록 서비스 제공

   

2. **TCP/IP 프로토콜을 스택 4계층으로 짓고 설명하시오**

   - LINK 계층 (OSI 1-2계층) : 물리적인 영역과 표준화에 대한 결과. 가장 기본이 되는 영역으로, LAN, WAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역
   - IP 계층 (OSI 3계층) : 경로 검색을 해주는 계층. IP 자체는 비연결지향적이고, 신뢰할 수 없는 프로토콜이다. 즉, 오류 발생에 대한 대비가 되어 있지 않은 프로토콜이다
   - TCP/UDP 계층 (OSI 4계층) : 데이터의 실제 송수신을 담당한다. UDP는 TCP에 비해 상대적으로 간단하고, TCP는 신뢰성 있는 데이터 전송을 담당한다. TCP 같은 경우에는 IP의 문제를 해결해준다. 데이터 순서가 올바르게 전송갔는지 확인해주며 대화를 주고받는 방식.
   - 애플리케이션 계층 (OSI 5-7계층) : 서버와 클라이언트를 만드는 과정에서 프로그램 성격에 따라 데이터 송수신에 대한 약속들이 정해지는데, 이것이 바로 애플리케이션 계층

   

3. **TCP란?**

   - 서버와 클라이언트의 함수 호출 순서가 중요하다 

   - **서버** : socket 생성 -> bind 소켓 주소 할당 -> listen 연결 요청 대기 상태 -> accept 연결 허용 -> read/write 데이터 송수신 -> close 연결 종료

   - **클라이언트** : socket 생성 -> connect 연결 요청 -> read/write 데이터 송수신 -> close 연결 종료

   - 둘의 차이는?

     > 클라이언트 소켓을 생성한 후, 서버로 연결을 요청하는 과정에서 차이가 난다.
     >
     > 서버는 listen() 호출 이후부터 연결요청 대기 큐를 만들어 놓고, 그 이후에 클라이언트가 연결 요청을 할 수 있다. 이때 서버가 바로 accept()를 호출할수 있는데, 연결되기 전까지 호출된 위치에서 블로킹 상태에 놓이게 된다
     >
     > 연결지향적인 TCP는 신뢰성 있는 데이터 전송이 가능하다 (3-way handshaking)
     >
     > 흐름제어와 혼잡제어를 지원해서 데이터 순서를 보장해준다
     >
     > - 흐름 제어 : 송신 측과 수신 측의 데이터 처리 속도 차이를 조절해줌
     > - 혼잡 제어 : 네트워크 내의 패킷 수가 넘치게 증하가지 않도록 방지함
     >
     > 정확성 높은 전송을 하기 위해 속도가 느린 단점이 있고, 주로 웹 HTTP 통신, 이메일, 파일 전송에 사용됨

   

4. **3-way handshaking**

   - TCP 소켓은 연결 설정 과정 중 총 3번의 대화를 주고 받는다
   - SYN : 연결 요청 플래그 / ACK : 응답

   > 1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보냄
   > 2. 서버는 클라이언트 요청인 SYN을 받고, 클라이언트에게 요청을 수락한다는 ACK와 SYN이 설정된 패킷을 발송함
   > 3. 클라이언트는 서버의 수락 응답인 ACK와 SYN 패킷을 받고, ACK를 서버로 보내면 연결이 성립됨

   

5. **UDP란?**

   - TCP의 대안으로, IP와 같이 쓰일 땐 UDP/IP라고 부른다
   - TCP와 마찬가지로, 실제 데이터 단위를 받기 위해 IP를 사용한다. TCP와는 달리 메시지를 패킷으로 나누고, 반대편에서 재조립하는 등의 서비스를 제공하지 않는다
   - 즉, 여러 컴퓨터를 거치지 않고 데이터를 주고 받을 컴퓨터끼리 직접 연결할 때 UDP를 사용한다
   - UDP를 사용해 목적지(IP)로 메시지를 보낼 수 있으며, 컴퓨터를 거쳐 목적지까지 도달할 수 있다. 도착하지 않을 가능성도 존재한다
   - 정보를 받는 컴퓨터는 포트를 열어두고, 패킷이 올 때까지 기다리며 데이터가 오면 모두 다 받아들인다. 패킷이 도착했을 때 출발지에 대한 정보(IP와 PORT)를 알 수 있다
   - UDP는 비신뢰적이고, 안정적이지 않은 프로토콜이다. TCP보다 3-way handshaking 과정을 거치지 않기 때문에 속도가 매우 빠르고 편해 데이터 유실이 일어나도 큰 상관이 없는 스트리밍이나 화면 전송에서 사용한다

   

6. **HTTP와 HTTPS의 차이는?**

   - HTTP 동작 순서 : TCP -> HTTP
   - HTTPS 동작 순서 : TCP -> SSL -> HTTP
   - SSL(Secure Socket Layer)을 쓰냐 안쓰냐 차이이다. SSL 프로토콜은 정보를 암호화시키고 이 때 공개키와 갱니키 두가지를 이용한다
   - HTTPS는 인터넷 상에서 정보를 암호화하기 위해 SSL 프로토콜을 이용해 데이터를 전송하고 있다는 것을 말한다. 즉, 문서 전송시 암호화 처리 유무에 따라 HTTP와 HTTPS로 나누어지는 것

   

7. **GET과 POST의 차이**

   - 둘 다 HTTP 프로토콜을 이용해 서버에 무언가를 요청할 때 사용하는 메소드
   - GET은 URL을 통해 모든 파라미터를 전달하기 때문에 주소창에 전달값이 노출된다. URL 길이에 제한이 있기 때문에, 전송 데이터 양이 한정되어 있고, 형식에 맞지 않으면 인코딩해서 전달해야 한다
   - POST는 HTTP BODY에 데이터를 포함해서 전달한다. 웹 브라우저 사용자의 눈에는 직접적으로 파라미터가 노출되지 않고 길이 제한도 없다
   - GET은 SELECT 성향, POST는 CREATE 성향이 강하다

   

8. **IOCP를 설명하시오**

   - IOCP는 어떤 I/O 핸들에 대해, 블록 되지 않게 비동기 작업을 하면서 프로그램 대기 시간을 줄이는 목적으로 사용된다
   - 동기화 Object 세마포어의 특성과, 큐를 가진 커널 Object다. 대부분 멀티 스레드상에서 사용되고, 큐는 자체적으로 운영하는 특징 때문에 스레드 풀링에 적합하다
   - 동기화와 동시에 큐를 통한 데이터 전달 IOCP는, 스레드 풀링을 위한 것이라고 할 수 있다

   

9. **POOLING 이란**

   - 여러 스레드를 생성하여 대기시키고, 필요할 때 가져다가 사용한 뒤에 다시 반납하는 과정
   - 스레드의 생성과 파괴는 상당히 큰 오버헤드가 존재하기 때문에 이 과정을 이용한다
   - 유니티에서도 게임 오브젝트를 생성하고 파괴하는데 큰 오버헤드가 들어 아이템 Pooling 풀을 이용하여 관리하기도 한다
   - IOCP의 장점은 사용자가 설정한 버퍼만 사용하기 때문에 더 효율적으로 작동시킬 수 있다 (기존에는 OS버퍼, 사용자 버퍼로 분리해 운영)
   - 커널 레벨에서는 모든 I/O를 비동기로 처리하기 때문에 효율적인 순서에 따라 접근할 수 있다

   

10. **라우터와 스위치의 차이**

    - 라우터는 3계층 장비로, 수신한 패킷의 정보를 보고 경로를 설정해 패킷을 전송하는 역할을 수행하는 장비
    - 스위치는 주로 내부 네트워크에 위치하며 MAC 주소 테이블을 이용해 해당 프레임을 전송하는 2계층 장비

    <br>


---

**다음주 주제** - **언어**

> **C**
>
> **C++**
>
> **C#**



