# Week3 - Operating System

[출처 : gyoogle](https://github.com/gyoogle/tech-interview-for-developer)

### 목차

[1. 운영체제란](#운영체제란)

[2. 프로세스 & 스레드](프로세스-&-스레드)

[3. 프로세스 주소 공간](#프로세스-주소-공간)

[4. 인터럽트(Interrupt)](#인터럽트(Interrupt))

[5. 시스템 콜(System Call)](#시스템 콜(System Call))

-----



#### 운영체제란

-----

**운영체제**는 **시스템의 자원과 동작을 관리하는 소프트웨어**

>**프로세스 관리**
>
>> 운영체제에서 작동하는 응용 프로그램을 관리하는 기능
>>
>> 현재 CPU를 점유해야 할 프로세스를 결정하고, cpu를 프로세스에 할당하며, 이 프로세스 간 공유 자원 접근과 통신 등을 관리
>
>
>
>**저장장치 관리**
>
>> 1차 저장장치에 해당하는 메인 메모리와 2차 저장장치에 해당하는 하드디스크, NAND 등을 관리하는 기능이다.
>>
>> > **1차 저장장치(Main Memory)**
>> >
>> > - 프로세스에 할당하는 메모리 영역의 할당과 해제
>> > - 각 메모리 영역 간의 침범 방지
>> > - 메인 메모리의 효율적 활용을 위한 가상 메모리 기능
>>
>> > **2차 저장장치(HDD, NAND Flash Memory)**
>> >
>> > - 파일 형식의 데이터 저장
>> > - 파일 시스템을 OS에서 관리
>> > - 파일 시스템 예시 : ``` FAT, NTFS, EXT2, JFS, XFS``` 
>
>
>
>**네트워킹**
>
>> TCP/IP 기반의 인터넷을 연결하거나, 응용 프로그램이 네트워크를 사용하려면 **운영체제에서 네트워크 프로토콜을 지원**해야 한다.
>
>
>
>**사용자 관리**
>
>> 하나의 컴퓨터를 여러 명이 사용할 수 있다. 이를 위해 운영체제는 각 계정을 관리할 수 있는 기능이 필요하다.
>>
>> 사용자 별로 파일이나 시스템 자원에 접근 권한을 지정할 수 있도록 지원하는 것이 사용자 관리 기능이다.
>
>
>
>**디바이스 드라이버**
>
>> 응용 프로그램이 하드웨어를 사용할 수 있게 만들도록 운영체제에서 인식하고 관리하게 만들어준다.
>>
>> 운영체제 안에 하드웨어를 추상화 해주는 계층인 디바이스 드라이버가 있다.



#### 프로세스 & 스레드

---

```
프로세스 : 프로그램을 메모리 상에서 실행중인 작업
스레드 : 프로세스 안에서 실행되는 여러 흐름 단위
```

**프로세스**

> 프로세스는 각각 별도의 주소공간 할당 (**독립적**)
>
> - Code : 코드 자체를 구성하는 메모리 영역 (프로그램 명령)
> - Data : 전역변수, 정적변수, 배열 등 (초기화 된 데이터는 data 영역, 이외는 bss 영역에 저장)
> - Heap : 동적 할당 시 사용 (new, malloc)
> - Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)
>
> 프로세스마다 메인 스레드 포함 최소 1개의 스레드 소유

**스레드**

> Stack만 따로 할당 받고 나머지 영역은 서로 공유

<img src="https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036" alt="img" style="zoom:70%;" />

**프로세스와 스레드의 차이**

> **프로세스**는 자신만의 고유 공간과 자원을 할당 받아 사용
>
> **스레드**는 다른 스레드와 공간, 자원을 공유하면서 사용



**멀티 프로세스**

> 하나의 컴퓨터에 여러 CPU를 장착 -> 하나 이상의 프로세스들을 동시에 처리 (병렬)
>
> 장점 : 안전성 (메모리 침범 문제를 OS 차원에서 해결)
>
> 단점 : 각각 독립된 메모리 영역을 갖고 있어, 작업량이 많을 수록 오버 헤드가 발생. Context Switching으로 인한 성증 저하
>
> 
>
> *Context Switching*
>
> > 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정
> >
> > 동작 중인 프로세스가 대기하면서 해당 프로레스의 상태를 보관하고,  대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말함
> >
> > ```프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재한다```

​             

**멀티 스레드**

>하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것
>
>공유 메모리를 통해 다수의 작업을 동시에 처리하도록 함
>
>장점 : 공유 메모리만큼의 시간, 자원 손실이 감소. 전역 변수와 정적 변수에 대한 자료 공유 가능
>
>단점 : 안전성 문제. 하나의 스레드가 데이터 공간을 망가뜨리면, 모든 스레드가 작동 불능한 병목현상 발생
>
>
>
>*Critical Section*
>
>> 멀티 스레드의 안전성에 대한 단점 대비 기법
>>
>> 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려고 할 때 발생하는 문제를 해결하기 위한 동기화 과정
>>
>> ```상호 배제, 진행, 한정된 대기```를 충족해야 함



**멀티 프로세스 vs 멀티 스레드 예제**

> Q.  크롬 웹브라우저는 멀티 프로세스? 멀티 스레드
>
> A. 멀티 프로세스
>
> > 멀티 스레드의 단점은 한 스레드에 오류가 생기면 다른 스레드에 영향을 미친다. 한 탭에 오류가 생겨도 다른 탭에서 사용할 수 있도록 멀티 프로세스로 되어 있다.



#### 프로세스 주소 공간

---

``` 프로그램이 CPU에 의해 실행됨 -> 프로세스가 생성되고 메모리에 프로세스 주소 공간이 할당됨```

**프로세스 주소 공간**

> - 코드 Segment : 프로그램 소스 코드 저장
> - 데이터 Segment : 전역 변수 저장
> - 스택 Segment : 함수, 지역 변수 저장

> 구역을 나눈 이유 : 최대한 데이터를 공유하여 **메모리 사용량을 감소**
>
> 프로그램의 함수와 지역변수는 LIFO 특성을 가진 스택에서 실행된다.



#### 인터럽트 (Interrupt)

---

> 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중이 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것
>
> 지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 한다.



> ```JAVA
> 외부/내부 인터럽트 -> CPU의 하드웨어 신호에 의해 발생
> 소프트웨어 인터럽트 -> 명령어의 수행에 의해 발생
> ```
>
> - **외부 인터럽트** : 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생
>
>   ```전원 이상, 기계 착오, 외부 신호, 입출력```
>
> - **내부 인터럽트** : Trap이라 부르며, 잘못된 명령이나 데이터를 사용할 때 발생
>
>   ```0으로 나누기 발생, 오버플로우, 명령어를 잘못 입력한 경우(Exception)```
>
> - **소프트웨어 인터럽트** : 프로그램 처리 중 명령의 요청에 의해 발생한 것 (SVC 인터럽트)
>
>   ```사용자가 프로그램을 실행시킬 때 발생, 소프트웨어 이용 중 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행```



**인터럽트 발생 처리 과정**

![img](https://mblogthumb-phinf.pstatic.net/20160310_124/scw0531_14575366291105WjS7_PNG/ERTRTETRE.png?type=w2)

인터럽트 발생 시 수행중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 저장하는 이유는 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문이다.



**인터럽트 VS 폴링**

컨트롤러가 입력을 받아들이는 방법(우선순위 판별 방법)

> **폴링 방식**
>
> > 사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식
> >
> > 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다.
> >
> > 하드웨어에 비해 속도가 느리며, 폴링 하는 시간에는 원래 하던 일에 집중할 수 가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있다.
>
> 
>
> **인터럽트 방식**
>
> > MCU 자체가 하드웨어적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식
> >
> > ```Daisy Chain, 병렬 우선순위 부여```
> >
> > 하드웨어로 지원을 받아야 하는 제약이 있지만, 신속한 대응이 가능하여 실시간 대응에 필수적인 기능이다.
> >
> > **즉, 발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법**



#### 시스템 콜 (System Call)

---

```Process 생성과 제어를 위한 System call```

> fork, exec는 새로운 Process 생성과 관련
>
> wait는 Process(Parent)가 만든 다른 Process(child)가 끝날 때까지 기다리는 명령
>
> - fork : 새로운 Process 생성. 동일한 프로세스의 내용을 여러 번 동작할 때 사용함
> - wait : child 프로세스가 종료될 때까지 기다리는 작업
> - exec : child에서 parent와 다른 동작을 하고 싶을 때 사용

