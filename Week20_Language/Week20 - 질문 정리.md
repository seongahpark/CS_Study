# Week 20 - 질문 정리

[출처 - Gyoogle Interview 중 Language](https://gyoogle.dev/blog/interview/%EC%96%B8%EC%96%B4.html)

1. **가비지 컬렉션이란?**

   정리되지 않은 메모리, 유효하지 않은 메모리 주소인 가비지를 정리해주는 프로그램

   Heap 메모리를 재활용 하기 위해 참조되지 않는 객체들을 해제시켜 가용한 공간을 만드는 작업

   프로그래머가 직접 메모리를 정리하지 않아도 되어 개발 속도가 대폭 향상된다

   메모리를 언제 되찾을지 결정하기 위한 오버헤드 발생 문제점 존재

   C, C++은 가비지 컬렉션이 자체적으로 존재하지 않고, C#, Java는 존재함

   

2. **Vector와 ArrayList의 차이는?**

   -  Vector : 동기식. 한 스레드가 벡터 작업 중이면 다른 스레드가 벡터 보유 불가능
   - ArrayList : 비동기식. 여러 스레드가 arraylist에서 동시 작업이 가능

   

3. **String과 StringBuffer의 차이는?**

   - String : 불변. 문자를 수정하려면 지우고 다시 생성해야 함(new) -> 문자열 연산이 많으면 기능이 떨어짐
   - StringBuffer : 가변. 한 번 만들고 필요할 때 크기를 변경하여 문자를 변경함 (append() 생각하면 됨)
   - StringBuilder : 동기화 지원 X. 멀티스레드 환경에 부적합 -> 싱글 스레드에서 StringBuffer보다 좋음

   

4. **Serialization이란?**

   직렬화. 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷으로 변환

   나중에 재구성 할 수 있게 자바 객체를 JSON으로 변환해주거나 JSON을 자바 객체로 변환해주는 라이브러리

   

5. **Java의 메모리 영역은?**

   - 메소드 / 스택 / 힙
   - 메소드 : 바이트 코드, 전역 변수, static 변수
   - 스택 : 매개 변수, 지역 변수 (사용 끝나면 바로 소멸, 컴파일 시 메모리 할당)
   - 힙 : new로 생성된 객체(c에서는 malloc()). 호출이 끝나도 사라지지 않고 프로그램 실행 시 동적 할당

   

6. **오버로딩과 오버라이딩 차이**

   - 오버로딩 : 메소드의 이름은 같고, 매개변수를 다르게 함으로써 여러 메소드를 만드는 것
   - 오버라이딩 : 부모클래스로부터 상속받은 메소드를 재정의하는 것. 자식 객체에서 오버라이딩한 메소드는 호출시 오버라이딩한 메소드가 우선시 되어 호출됨(동일한 리턴타입, 메소드 이름, 매개변수를 가져야 함)

   

7. **추상 클래스와 인터페이스의 차이**

   - 추상클래스 : 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우. extends를 통해 기능을 이용하고 확장하도록 하는 클래스
   - 인터페이스 : 모든 메소드가 추상 메소드인 경우 (여러 implements가 가능해 다중 상속 구현 가능) 뼈대만 있으며, 구현하는 모든 클래스에 대해 강제적으로 메소드를 구현하도록 만듦

   

8. **제네릭**

   - 클래스에서 사용할 타입을 클래스 외부에서 설정하도록 만드는 것
   - 제네릭으로 선언한 크래스는, 내가 원하는 타입으로 만들어 사용이 가능
   - ``<``안에는 참조자료형(클래스, 인터페이스, 배열)만 가능
   - 기본자료형을 이용하기 위해서는 wrapper 클래스를 활용해야 함

   

9. **접근 지정자 4가지**

   - public : 모든 접근 허용
   - protected : 상속받은 클래스 or 같은 패키지만 접근 허용
   - default : 기본 제한자. 자신 클래스 내부 or 같은 패키지만 접근 허용
   - private : 외부 접근 불가능. 같은 클래스 내에서만 가능

   

10. **Call by Value vs Call by Reference**

    - 값에 의한 호출 : 값을 복사해서 새로운 함수를 넘기는 호출 방식. 원본 값 변경 X
    - 참조에 의한 호출 : 주소 값을 인자로 전달하는 호출 방식. 원본 값 변경 O

    - 스택 오버 플로우를 함수 호출 방식으로 어떻게 줄일 수 있는가? 

      > 함수 호출 시 이전의 호출한 스택 메모리는 종료하면 된다. (꼬리 재귀 방식)
      >
      > 다음 함수 호출 시 함수의 연산된 결과를 전달하면 됨

      

11. **배열과 연결리스트의 차이**

    - 배열

      - 인덱스를 가져 원하는 데이터를 한 번에 접근 가능하여 접근 속도가 빠름
      - 크기 변경이 불가능
      - 데이터 삽입 및 삭제 시 그 위치의 다음 위치부터 모든 데이터 위치를 변경해야되는 단점
      - 탐색 시간 복잡도  : O(1)

    - 연결리스트

      - 인덱스 대신 현재 위치의 이전/다음 위치를 기억
      - 크기가 가변적
      - 인덱스 접근이 아니라 연결되어 있는 링크를 쭉 따라가야 접근이 가능해 배열보다 속도 느림
      - 데이터 삽입/삭제가 논리적 주소만 바꿔주면 돼 용이하다
      - 탐색 시간 복잡도 : O(n)

      

12. **Hash**

    데이터 삽입 및 삭제 시, 기존 데이터를 밀어내거나 채우지 않고 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법

    검색 속도가 매우 빠름

    

13. **Java 컴파일 과정**

    컴파일러가 소스코드를 자바 바이트 코드(.class)로 변환

    JVM이 바이트코드를 기계어로 변환하고, 인터프리터 방식으로 애플리케이션 실행

    

14. **C++ 실행 과정**

    - 전처리 : #define, #include 지시자 해석
    - 컴파일 : 고급 언어 소스 프로그램을 입력 받고, 어셈블리 파일 만듦
    - 어셈블 : 어셈블리 파일을 오브젝트 파일로 만듦
    - 링크 : 오브젝트 파일을 엮어 실행파일을 만들고 라이브러리 함수 연결
    - 실행

    

15. **메모리, 성능을 개선하기 위해 생각나는 방법**

    static을 사용해 선언

    인스턴스 변수에 접근할 일이 없으면, static 메소드를 선언하여 호출

    모든 객체가 서로 공유 가능해 메모리가 절약되고, 연속적으로 그 값의 흐름을 이어갈 수 있는 장점

    

16. **클래스와 구조체 차이**

    구조체는 하나의 구조로 묶일 수 있는 변수들의 집합

    클래스는 변수 뿐만 아니라, 메소드도 포함시킬 수 있음

    함수 포인터를 이용해 구조체도 클래스처럼 만들 수 있다

    

17. **스레드의 생성방식과 장단점**

    - 생성 방식 : Runnable(인터페이스)로 선언되어 있는 클래스 or Thread 클래스를 상속받아 run() 메소드를 구현하면 됨
    - 장점 : 빠른 프로세스 생성, 메모리를 적게 사용 가능, 정보 공유가 쉬움
    - 단점 : 데드락에 빠질 위험 존재

    

18. **포인터를 이해하기 쉽도록 설명**

    포인터는 메모리 주소를 저장하는 변수

    주소를 지칭하는 곳이니 엘리베이터 포인터라고 예시를 들면, 해당 층을 표시하는 버튼이라고 할 수 있다. 10층 버튼은 10층 위치를 가리키는 변수

    포인터를 사용 시 주의할 점은, 어떤 주소를 가리키고 있어야만 사용이 가능하다

<br>

---

**다음주 주제** - **Interview - 운영체제**

> **운영체제**



