# Week 28 - Unity

1. **GameObject & Component**

    > GameObject 클래스는 씬 내에 존재할 수 있는 모든 요소를 나타내는 데 사용된다
    >
    > Component는 모든 게임 오브젝트의 구성

    - 게임 오브젝트 활성 상태 제어 : `SetActive()`
    - 컴포넌트 액세스 : `GetComponent<Type>()`
    - 타 컴포넌트 액세스 : `public GameObject` 선언 후, 인스펙터에서 연결


2. **URP**

    > URP(유니버설 렌더 파이프라인)은 유티니에서 제작한 사전 빌드된 스크립터블 렌더 파이프라인

    - 최적화된 그래픽스를 쉽고 빠르게 구현하도록 도와준다
    - 한 번만 개발하여도 Unity를 지원하는 플랫폼에 배포가 가능하다
    - 2D, 3D, XR 등 모든 종류의 프로젝트에 최적화되어 있다


3. **Drawcall & Batching**

    > DrawCall : 한 프레임 마다 오브젝트를 하나하나 그릴 때 마다 정보들이 CPU에서 GPU로 전달되고 그려지는데, 이 때, CPU가 GPU에게 보내는 명령을 DrawCall이라 한다

    - DrawCall은 리소스가 많이 사용되어 CPU 성능이 많이 소모될 수 있다
    - 즉, **CPU 바운드의 병목현상**의 원인이 된다
    - 이를 해결하기 위해 유니티에서는 동적 배칭과 정적 배칭을 사용한다

    > 배칭 : 드로우 콜을 줄이는 작업. 여러 배치를 묶어 하나의 배치로 만든다
    >
    > 동적 배칭 : 메시가 충분히 작은 경우 사용. 메시의 버텍스가 CPU에서 트랜스폼 되고, 여러 유사한 메시가 그룹화되어 한꺼번에 드로우된다.
    >
    > 정적 배칭 : 정적인 게임 오브젝트를 큰 메시로 합치고 더 빠른 방법으로 렌더링 한다

    - 동적 배칭은 CPU 리소스를 많이 사용하여 비교적 덜 사용된다
    - 정적 배칭은 주로 배경 리소스에서 많이 사용되며, 메모리와 스토리지가 많이 소요된다


4. **세대별 가비지 컬렉션**

    > 세대별 가비지 컬렉션 알고리즘은 오래 살아남을 것 같은 객체를 모아놓고 비교적 관심을 덜 주는 형태로 구현

    #### 알고리즘 구조
    1. 새로 할당된 객체들 모두 0세대에 포함한다
    2. 0세대가 임계치에 도달하면 가비지 컬렉터는 0세대에 대해 가비지 컬렉션을 수행한다
    3. 이후 살아남은 객체들은 1세대로 옮긴다
    4. 또 다른 객체가 할당되면 0세대로 포함된다
    5. 1세대가 임계치에 도달하면 마찬가지로 가비지 컬렉션을 수행한다
    6. 살아남은 객체들은 2세대로 옮겨진다
    7. 2세대가 포화하게 되면 더 이상 다른 곳으로 옮길 수 없기 때문에 전체 가비지 컬렉션을 수행한다

    즉, 0, 1, 2세대를 구분하여 각각의 임계치에 도달하면 해당 세대에 대해 가비지 컬레션을 수행하는 알고리즘이다 (단, 2세대는 전체 수행)


5. **Mono & il2cpp**

    - Mono와 il2cpp은 유니티에서 다른 플랫폼용으로 프로젝트를 빌드할 때 사용하는 방법이다
    - il2cpp은 어셈블리 언어인 IL을 C++ 소스코드로 변환하여 C++로 어셈블리를 추가할 수 있게 해준다

    #### 추가 지식
    - SDK : 소프트웨어 프로그래밍 개발 킷
    - JDK : 안드로이드 어플 개발시 JAVA 코드로 개발할 수 있게 도와주는 킷
    - NDK : 안드로이드 어플 개발시 C 코드로 개발할 수 있게 도와주는 킷
