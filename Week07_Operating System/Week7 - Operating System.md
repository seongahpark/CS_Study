# Week 7 - Operating System

[출처 : gyoogle](https://gyoogle.dev/blog/computer-science/operating-system/Paging%20and%20Segmentation.html)

### 목차

[1. 페이징과 세그먼테이션](#페이징과-세그먼테이션)

[2. 페이지 교체 알고리즘](#페이지-교체-알고리즘)



---

<br>

## 페이징과 세그먼테이션

**기법의 필요성**

> 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적분할하는 메모리 관리 작업이 필요



**용어**

- 페이지 : 고정 사이즈의 작은 프로세스 조각
- 프레임 : 페이지 크기와 같은 주기억장치 메모리 조각
- 단편화 : 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상
- 세그먼트 : 서로 다른 크기를 가진 논리적 블록이 연속된 공간에 배치

> **고정크기** : 페이징 (Paging)
>
> **가변크기** : 세그먼테이션 (Segmentation)



#### 메모리 관리 기법

1. 연속 메모리 관리

   > 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당

   - 고정 분할 기법 : 주기억장치가 고정된 파티션으로 분할 (**내부 단편화 발생**)
   - 동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 (**외부 단편화 발생**)

2. 불연속 메모리 관리

   > 프로그램 일부가 서로 다른 주소 공간에 할당될 수 있는 기법

- **단순 페이징**

  > 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨
  >
  > 외부 단편화 X
  >
  > 소량의 내부 단편화 O

- **단순 세그먼테이션**

  > 각 프로세스는 여러 세그먼트들로 나뉨
  >
  > 내부 단편화 X
  >
  > 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소
  >
  > 외부 단편화 O

- **가상 메모리 페이징**

  > 단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요 X
  >
  > 필요한 페이지가 있으면 나중에 자동으로 불러짐
  >
  > 외부 단편화 X
  >
  > 복잡한 메모리 관리로 오버헤드 발생

- **가상 메모리 세그먼테이션**

  > 필요하지 않은 세그먼트들은 로드 X
  >
  > 필요한 세그먼트가 있을 시 나중에 자동으로 불러들임
  >
  > 내부 단편화 X
  >
  > 복잡한 메모리 관리로 오버헤드 발생

<br>

---

<br>

## 페이지 교체 알고리즘

#### 페이지 교체 알고리즘 개요

- 페이지 부재가 발생하여 새로운 페이지를 할당해야 할 때, 현재 할당된 페이지 중 어떤 것을 교체할지(out) 결정하는 방법
- 이 때 out이 되는 페이지를 victim page라 부름
- 수정이 되지 않는 페이지를 선택하는 것이 좋다 -> 수정되면 메인 메모리에서 내보낼 때, 하드디스크에서 또 수정을 진행해야 돼 시간이 오래 걸린다



#### Page Reference String

> CPU의 주소 요구에 따라 페이지 결함이 일어나지 않는 부분은 생략하여 표시하는 방법

- CPU는 논리 주소를 통해 특정 주소를 요구함
- 메인 메모리에 올라와 있는 주소들은 페이지의 단위로 가져오기 때문에 페이지 번호가 연속되어 나타나게 되면 페이지 결함 발생 X



#### 페이지 교체 알고리즘

1. **FIFO 알고리즘**

   > First-in First-out, 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘

   - victim page : 가장 먼저 메모리에 올라온 페이지
   - 가장 간단한 방법, 초기화 코드에서 적절한 방법
   - 처음 프로세스 실행시에는 초기화 코드가 반드시 필요하므로, FIFO를 사용하면 초기화를 시켜준 후 가장 먼저 내보내는 것이 가능함
   - ```초기화 코드``` : 처음 프로세스 실행 시 최초 초기화를 시키는 역할만 진행. 메인 메모리에서 빼도 된다.

   ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FVQCGK%2FbtquJuqRkyS%2FLb3NgwHkBve08YhZpLkq31%2Fimg.png)

2. **OPT 알고리즘**

   > Optimal 알고리즘, 앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄

   - FIFO에 비해 페이지 결함의 횟수를 감소시킬 수 있음
   - 실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없어 수행하기 어려움

   ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FSvRs7%2FbtquHbeJLQX%2FWXmK7xdGUbIxl43t0JG6Qk%2Fimg.png)

3. **LRU 알고리즘**

   > Least-Recently-Used, 최근에 사용하지 않은 페이지를 가장 먼저 내보냄

   - 최근에 사용하지 않았으면 나중에도 사용되지 않을 것이라는 아이디어에서 나옴
   - OPT는 미래 예측이지만, LRU는 과거를 보고 판단하므로 실질적으로 사용이 가능
   - OPT보다 페이지 결함이 더 일어날 수 있지만, 실제로 사용 할 수 있는 페이지 교체 알고리즘에서는 가장 좋은 방법

   ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FnCgc3%2FbtquGW9VUrm%2FxTKnVKPOVQuSXmAuRehSw1%2Fimg.png)

4. **LFU (Least Frequently Used)**

   - 사용 빈도가 가장 적은 페이지 교체
   - LRU는 직전 참조된 시점만을 반영하지만, LFU는 참조 횟수를 통해 장기적 시간규모에서의 참조성향을 고려할 수 있음
   - 바로 불러온 페이지가 교체될 수 있다는 단점이 존재
   - 구현이 더 복잡, 막대한 오버헤드가 발생할 수 있음

5. **NUR (Not Used Recently)**

   - LRU와 비슷한 방식, 최근에 사용하지 않은 페이지 교체

   - LRU 교체의 단점인 시간 오버헤드를 적게하는 방법

   - 동일 그룹 내에서 무작위로 선택

   - 최근 사용여부를 확인하기 위해 각 페이지마다 두 개의 비트 사용

     > 참조비트 : 페이지가 호출되었을 때는 1, 호출되지 않았을 때는 0
     >
     > 변형비트 : 페이지 내용이 변경되었을 때는 1, 변경되지 않았을 때는 0
     >
     > 우선순위 : 참조비트 > 변형비트

   ![img](https://blog.kakaocdn.net/dn/qfdHU/btq9PTLnM9o/7Xg5UGO0UYs3qeXjJwTiW1/img.png)

6. **MFU (Most Frequently Used)**

   - 가장 많이 사용된 페이지가 앞으로는 사용되지 않을 것으로 예상하고 구현



#### 교체 방식

- Global 교체 : 메모리 상의 모든 프로세스 페이지에 대해 교체
- Local 교체 : 메모리 상의 자기 프로세스 페이지에서만 교체

다중 프로그래밍의 경우, 메인 메모리에 다양한 프로세스가 동시에 올라올 수 있어 다양한 프로세스의 페이지 메모리가 존재함.

이 때, victim page 선정 시 선정기준을 Global로 하느냐, Local로 하느냐에 대한 차이.

-> 실제로는 전체를 기준으로 페이지를 교체하는 것이 더 효율적. 자기 프로세스 페이지에서만 교체를 하면, 교체시 각각 모두 교체를 진행해야하므로 비효율적

