# Week6 - Software Engineering

[출처 : gyoogle](https://gyoogle.dev/blog/computer-science/software-engineering/Object-Oriented%20Programming.html)

#### 목차

[1. 객체 지향 프로그래밍](#객체-지향-프로그래밍)

[2. 함수형 프로그래밍](#함수형-프로그래밍)



---

<br>

## 객체 지향 프로그래밍

1. **순차적, 비구조적 프로그래밍**

   필요한 게 있으면 순서대로 추가해가며 구현하는 방식

   **goto문** 활용 -> 무분별한 goto문은 코드의 흐름을 이해하는 데 시간을 소비할 가능성이 큼

   

2. **절차적, 구조적 프로그래밍**

   반복될 가능성이 있는 것들을 재사용이 가능한 **함수(프로시저)**로 만들어 사용

   절차는 함수를 뜻하고, 구조는 모듈을 뜻함

   > **프로시저**
   >
   > 반환값(리턴)이 존재하지 않는 함수 ex) 화면에 출력할 용도로 쓰이는 printf 함수
   >
   > *정확히 말하면 printf는 int형을 리턴해주긴 하지만 목적 자체는 프로시저에 가깝다*

   문제점은 자료형과 함수가 물리적으로 같이 있을 수 있지만 논리적으로 함께할 수 없는 구조이기 때문에 구분하기 힘들고 비효율적일 가능성이 높음

   

3. **객체지향 프로그래밍**

   **특정한 개념의 함수와 자료형을 함께 묶어서 관리하기 위해 탄생**

   객체 내부에 **자료형(필드)**와 **함수(메소드)**가 같이 존재

   객체 간의 독립성이 생기고 중복코드 양이 줄어들어 유지보수에 좋다

- **객체지향 프로그래밍의 특징**

  > **1. 추상화 (Abstraction)** : 필요로 하는 속성이나 행동을 추출하여 하나의 집합으로 만듦
  >
  > ​	추상화의 장점은 추가로 만들 부분만 새로 생성하면 되는 것으로 유지보수가 편리하다
  >
  > 
  >
  > **2. 캡슐화 (Encapsulation)** : 한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시	켜 낮은 결합도를 유지할 수 있도록 설계
  >
  > ​	```결합도는 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타냄```
  >
  > ​	**정보 은닉**을 활용하여 높은 응집도와 낮은 결합도를 갖게 함 -> 외부에서 접근할 필요가 없	는 것들은 private으로 제한을 둔다
  >
  > 
  >
  > **3. 상속 (Generalization)** : 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법	칙으로 성립
  >
  > ​	**자식 클래스를 외부로부터 은닉하는 캡슐화의 일종**
  >
  > ​	**※ 상속 재사용의 단점**
  >
  > - 상위 클래스(부모 클래스)의 변경이 어려워진다 : 의존하는 자식 클래스들까지 영향을 받기 때문
  >
  > - 불필요한 클래스가 증가할 수 있다 : 유사기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 할 수 도 있다
  >
  > - 상속이 잘못 사용될 수 있다 : 상속 받는 클래스가 부모 클래스와 IS-A 관계가 아닐 때 해당
  >
  >   > **IS-A** : 클래스 A가 다른 클래스 B의 파생클래스(상속)임을 말함. ex) 사과는 과일이다
  >   >
  >   > **HAS-A** : 상속이 아닌 일반적인 포함 개념의 관계. A가 B를 가지고 있음. ex) 차는 바퀴를 가지고 있다
  >
  > - **해결책** : 객체 조립을 적용한다. 상속에 비해 런타임 구조가 복잡해지고, 구현이 어려운 단점이 있지만, 변경 시 유연함을 확보하는데 장점이 크다
  >
  >   ``객체 조립 (Composition)``은 **필드에서 다른 객체를 참조하는 방식으로 구현**
  >
  > - **상속을 사용하는 경우** : ``IS-A 관계``가 성립, 재사용의 관점이 아닌 기능의 ``확장`` 관점일 때
  >
  > **4. 다형성 (Polymorphism)** : 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력 -> 코드를 간결하게 해주고 유연함을 갖추게 함
  >
  > ​	**부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용**
  >
  > > ※ **오버로딩 & 오버라이딩**
  > >
  > > - **오버로딩 (Overloading)** : 같은 이름의 메소드를 여러개를 가지면서 매개변수의 유형과 개수에 따라 다르게 동적하는 기술
  > > - **오버 라이딩 (Overriding)** : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용 (부모와 자식의 메소드 이름이 같고, 매개변수가 같고, 반환형이 같을 때 자식 클래스의 메소드 기능을 사용함)

- **객체 지향 설계 과정**

  > - 제공해야 할 기능을 찾고 세분화하여 알맞은 객체에 할당한다
  > - 기능을 구현하는데 필요한 데이터를 객체에 추가한다
  > - 데이터를 이용하는 기능을 넣는다
  > - 기능은 최대한 캡슐화하여 구현한다
  > - 객체 간 어떻게 메소드 요청을 주고받을 지 결정한다

- **객체 지향 설계 원칙 (SOLID)** 

  > 1. **SRP (Single Responsibility)** : 단일 책임 원칙, 클래스를 변경하는 이유는 단 한개
  > 2. **OCP (Open-Closed)** : 개방-폐쇄 원칙, 확장에는 열려있고, 수정에는 닫힘
  > 3. **LSP (Liskov Substitution)** : 리스코프 치환 원칙, 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 작동
  > 4. **ISP (Interface Segregation)** : 인터페이스 분리 원칙, 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리. 사용하지 않는 인터페이스에 변경이 생겨도 영향을 받지 않아야 함
  > 5. **DIP (Dependency Inversion)** : 의존 역전 원칙, 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안됨. 저수준 모듈이 변경돼도 고수준 모듈은 변경할 필요가 없어야 함

<br>

---

<br>

## 함수형 프로그래밍

> 순수 함수를 조합하고 공유 상태, 변경 가능한 데이터 및 부작용을 피해 소프트웨어를 만드는 프로세스



![img](https://user-images.githubusercontent.com/6733004/46247710-5ce5fb00-c44a-11e8-9400-16dd44626820.png)

사진은 빼먹으면 섭섭할 것 같아서 넣었다.

---

내용 추가할 부분

solid 파일에서 ocp에서 instance of와 다운캐스팅 부분 추가하기

  