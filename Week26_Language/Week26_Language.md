# Week 26 - Language(C++)

1. **C++의 스마트 포인터**

   > 스마트 포인터(smart pointer)란 포인터처럼 동작하는 클래스 템플릿으로, 사용이 끝난 메모리를 자동으로 해제해 준다

   - 메모리 누수로부터 프로그램의 안전성을 보장하기 위해 스마트 포인터를 사용한다

   - new 키워드를 사용해 기본 포인터(raw pointer)가 실제 메모리를 가리키도록 초기화한 후에, 기본 포인터를 스마트 포인터에 대입하여 사용함

   - 스마트 포인터의 수명이 다하면, 소멸자가 delete 키워드를 통해 할당된 메모리를 자동 해제한다

   - **스마트 포인터의 종류**
    0. **auto_ptr**

        - C++11 이전에 사용했던 스마트 포인터. C++11부터 삭제됨

    1. **unique_ptr**
        - 하나의 스마트 포인터만이 특정 객체를 소유할 수 있도록, 객체에 소유권 개념을 도입한 스마트 포인터

        - 해당 객체의 소유권을 가지고 있을 때만, 소멸자가 해당 객체를 삭제할 수 있다

        - unique_ptr 인스턴스는 `move()` 멤버 함수를 통해 소유권 이전이 가능하다. 단, 복사는 불가능

        - 소유권이 이전되면, 이전 unique_ptr 인스턴스는 더는 해당 객체를 소유하지 않게 재설정됨

        ```cpp
        unique_ptr<int> ptr01(new int(5)); // int형 unique_ptr인 ptr01을 선언하고 초기화함.
        auto ptr02 = move(ptr01);          // ptr01에서 ptr02로 소유권을 이전함.
        unique_ptr<int> ptr03 = ptr01;  // 대입 연산자를 이용한 복사는 오류를 발생시킴. 
        ```
    
    2. **shared_ptr**

        - 하나의 특정 객체를 참조하는 스마트 포인터가 총 몇 개인지 참조하는 스마트 포인터

        - 참조하고 있는 스마트 포인터의 개수를 참조 횟수(reference count)라고 한다

        - 참조 횟수는 특정 객체에 새로운 shared_ptr이 추가될 때마다 1씩 증가하며, 수명이 다할 때마다 1씩 감소

        - 참조 횟수가 0이 되면 `delete` 키워드를 사용하여 메모리를 자동으로 해제한다

        ```cpp
        shared_ptr<Person> hong = make_shared<Person>("길동", 29);
        cout << "현재 소유자 수 : " << hong.use_count() << endl; // 1
        auto han = hong;
        cout << "현재 소유자 수 : " << hong.use_count() << endl; // 2
        han.reset(); // shared_ptr인 han을 해제함.
        cout << "현재 소유자 수 : " << hong.use_count() << endl; // 1
        ```

        - 한계점 : 서로가 상대방을 가리키는 shared_ptr을 가지고 있다면, 참조 횟수는 절대 0이 되지 않으므로 메모리는 영원히 해제되지 않는다 -> **순환 참조 (circular reference)**

    3. **weak_ptr**

        - shared_ptr의 단점을 보완하기 위해 사용하는 스마트 포인터

        - 하나 이상의 shared_ptr 인스턴스가 소유하는 객체에 대한 접근을 제공하지만, 소유자의 수에는 포함되지 않는 스마트 포인터

        - shared_ptr 인스턴스 사이의 순환 참조를 제거하기 위해 사용된다

        - mutext처럼 `lock`이 걸린 상태에서만 개수를 세기 때문에, 인스턴스를 사용 중이 아니면 소멸자를 호출할 수 있는 원리


2. **우측값 vs 좌측값**

    > int count = 0; // 0은 우측값, count는 좌측값

    1. 우측값(오른값)

        - 식이 끝나면 존재하지 않는 임시값

        - 우측값 참조는 `&&` 연산자를 사용한다

        > int&& ref = 10;

    2. 좌측값

        - 식이 끝난 후에도 계속 존재하는 값

        - 좌측값 참조는 `&` 연산자를 사용한다

        > int count;
        > 
        > int& ref = count;

    3. Move 생성자 & Move 대입연산자

        - 클래스를 정의할 때, 복사, 대입연산자와 같이 Move 생성자, Move 대입연산자를 정의할 수 있다

        - 리소스 복사가 아닌 메모리 이동을 가능하게 한다

    4. `std::move`

        - `std::move`는 좌측값을 우측값으로 캐스팅하기 위해 제공하는 함수이다

        - 주의! 우측값은 식이 끝나면 사라지는 값이니, `std::move`를 통해 좌측값을 우측값으로 바꿨을 때, 우측값으로 바뀐 좌측값은 다음에 사용할 수 **없다**

    4. `std::forward`

        - `std::forward`는 좌측값은 좌측값으로, 우측값은 우측값으로 캐스팅 해주는 함수
        

3. **RTTI**

    > Run Time Type Information이라 하며, 프로그램 실행 중에 실시간으로 데이터 타입을 얻어올 때 사용하는 방법이다

    - `typeid(변수)`, `typeid(데이터 타입)`과 같은 형식으로 타입의 정보를 얻어올 수 있다


4. **auto**

    - 선언의 초기화 식에서 형식이 추론되는 변수를 선언하는 역할

    - 함수의 매개변수, 구조체나 클래스 등의 멤버 변수로는 사용될 수 없으나, 리턴형으로는 사용 가능하다


5. **댕글링 포인터**

    > 포인터가 여전히 해제된 메모리 영역을 가리키고 있을 때 댕글링 포인터라고 한다

    - 댕글링 포인터는 premature free(조숙한 해제)라고 부르기도 한다

    - 위험성

        - 메모리 접근시 예측 불가능한 동작 발생 위험
        
        - 메모리 접근 불가시 Segmentation fault 오류

        - 잠재적인 보안 위험


6. **포인터와 레퍼런스(`*`와 `&`)**

    - 포인터 : 메모리의 주소를 가지고 있는 변수로 주소값을 통한 메모리 접근을 한다 -> **간접 참조**

    - 레퍼런스 : 자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름. 즉 변수에 별명을 붙여주는 것과 같다. 변수명을 통해 메모리를 직접 참조한다 -> **직접 참조**

    - 포인터는 NULL을 허용하지만, 레퍼런스는 NULL을 허용하지 않는다

7. **NULL과 nullptr의 차이**

    - `NULL`은 상수 0을 의미한다

    - `nullptr`은 null 포인터 상수를 의미한다

    - 즉, 포인터 변수를 초기화해줄 때, `nullptr`을 사용해야 한다

