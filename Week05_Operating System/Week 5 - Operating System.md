# Week 5 - Operating System

[출처 : gyoogle](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html)

### 목차

[1. 데드락(DeadLock)](#데드락(DeadLock))

[2. 경쟁 상태(Race Condition)](#경쟁-상태(Race-Condition))

[3. 세마포어와 뮤텍스](#세마포어와-뮤텍스)

---

<br>

## 데드락(DeadLock)

1. **데드락** : 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태. ``교착상태``라고도 함. 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생

2. **데드락이 주로 발생하는 경우**

   > - 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생
   > - 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음. 이 때 프로세스는 대기 상태로 들어감
   > - 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 ``교착 상태`` 발생

3. **데드락 발생 조건**

   >**4가지 모두 성립해야 데드락 발생 -> 하나라도 성립하지 않으면 데드락 해결 가능**
   >
   >1) **상호 배제(Mutual Exclusion)** : 자원은 한 번에 한 프로세스만 사용할 수 있음
   >
   >2) **점유 대기(Hold and Wait)** : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
   >
   >3) **비선점(No Preemption)** : 다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없음
   >
   >4) **순환 대기(Circular Wait)** : 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

4. **데드락 처리**

   > **교착 상태를 예방 & 회피 하는 방법**
   >
   > 1) **예방 (Prevention)** : 교착 상태 발생 조건 중 하나를 제거하여 해결 -> 자원 낭비가 심하다
   >
   > - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
   > - 점유대기 부정 : 프로세스 실행 전 모든 자원을 할당
   > - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
   > - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구
   >
   > 2) **회피 (Avoidance)** : 교착 상태 발생 시 피해나가는 방법
   >
   > - 은행원 알고리즘 (Banker's Algorithm)
   >   - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래
   >   - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착상태 회피
   >   - 안정 상태면 자원 할당, 아닐 시 다른 프로세스들이 자원 해지까지 대기
   >
   > ---
   >
   > **교착 상태를 탐지 & 회복 하는 방법**
   >
   > -> 교착상태가 되도록 허용한 다음 회복시킴
   >
   > 1) **탐지 (Detection)**
   >
   > - 자원 할당 그래프를 통해 교착 상태 탐지
   > - 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생
   > - 탐지 알고리즘 호출 주기
   >   - 자원을 요청햇는데 즉시 할당되지 못하는 시점
   >   - 주기적으로 일정 시간마다
   >   - CPU 이용률이 특정 값 이하로 떨어지는 시점
   >
   > 2) **회복 (Recovery)**
   >
   > -> 교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시킴
   >
   > - 프로세스 종료 방법
   >   - 교착 상태의 프로세스를 모두 중지
   >   - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
   > - 자원 선점 방법
   >   - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시 정지)
   >   - 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점

<br>

---

<br>

## 경쟁 상태 (Race Condition)

>공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태 -> **자료의 일관성**을 해침

#### Race Condition이 발생하는 경우

1. **커널 작업을 수행하는 중에 인터럽트 발생**
   - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다 인터럽트가 발생해 같은 데이터를 조작
   - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가지지 못하도록 함
2. **프로세스가 System Call을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때**
   - 문제점 : 프로세스 1이 커널모드에서 데이터를 조작하는 도중, 시간 초과로 CPU 제어권이 프로세스 2로 넘어가 같은 데이터를 조작하는 경우 (프로세스 2가 작업에 반영되지 않음)
   - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초가되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함
3. **멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때**
   - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
   - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때 마다, 그 데이터에 대한 LOCK / UNLOCK을 하는 방법

<br>

---

<br>

## 세마포어와 뮤텍스

#### 세마포어 (Semaphore)

> 공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있기 때문에 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한하는 방법이 필요하다.
>
> **세마포어**는 ``멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법``을 말한다.

**임계 구역 (Critical Section)**

- 여러 프로세스가 데이터를 공유하며 수행될 때, **각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분**
- 한 프로세스가 임계 구역을 수행할 때 다른 프로세스가 접근하지 못하도록 해야 함

**세마포어 P, V 연산**

- P : 임계 구역 들어가기 전에 수행 (프로세스 진입 여부를 자원의 개수 S를 통해 결정)
- V : 임계 구역에서 나올 때 수행 (자원 반납 알림, 대기 중인 프로세스를 깨우는 신호)
- 한 프로세스가 P 혹은 V를 수행하고 있는 동안 프로세스가 인터럽트 당하지 않게 된다.
- P와 V를 통해 임계 구역에 대한 상호 배제 구현

> **예시**
>
> 가정 : 최초 S 값은 1, 현재 해당 구역을 수행할 프로세스 A, B
>
> 1. 먼저 도착한 A가 P(S)를 실행하여 S를 0으로 만들고 임계구역에 들어감
> 2. 그 뒤에 도착한 B가 P(S)를 실행하지만 S가 0이므로 대기 상태
> 3. A가 임계구역 수행을 마치고 V(S)를 실행하며 S는 다시 1이 됨
> 4. B는 이제 P(S)에서 while문을 빠져나올 수 있고(0이 1이될 때 까지 기다리는 while문), 임계구역으로 들어가 수행

<br>

#### 뮤텍스 (Mutex)

> 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술.
>
> 상호 배제(**Mut**al **Ex**clusion)의 약자
>
> 해당 접근을 조율하기 위해 lock과 unlock 사용
>
> 뮤텍스는 상태가 0, 1로 **이진 세마포어**로 부르기도 함

- lock : 현재 임계 구역에 들어갈 권한을 얻어 옴 (만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때 까지 대기)
- unlock : 현재 임계 구역을 모두 사용했음을 알림 (대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음)

**뮤텍스 알고리즘**

1. **데커(Dekker) 알고리즘**

   - flag와 turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정
   - flag : 프로세스 중 누가 임계구역에 진입할 것인지 나타냄
   - turn : 누가 임계구역에 들어갈 차례인지 나타냄

   ```c++
   while(true){
   	flag[i] = true; //프로세스 i가 임계구역 진입 시도
       while(flag[j]){ //프로세스 j가 현재 임계구역에 있는지 확인
           if(turn == j){ //j가 임계 구역 사용 중
               flag[i] = false;
               while(turn == j); //turn이 j에서 변경될 때까지 대기
               flag[i] = true; //j turn이 긑나면 다시 진입 시도
           }
       }
   }
   // ----------임계 구역------------
   
   turn = j; // 임계 구역 사용 끝나면 turn을 넘김
   flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
   ```

   

2. **피터슨(Peterson) 알고리즘**

   - 데커와 유사하지만, 상대방 프로세스/스레드에게 진입 기회를 양보하는 것에 차이가 있음

   ```c++
   while(1){
   	flag[i] = true; //프로세스 i가 임계구역 진입 시도
       turn = j; //다른 프로세스에게 진입 기회 양보
       while(flag[j] && turn == j){
           //다른 프로세스가 진입 시도하면 대기
       }
   }
   // ----------임계 구역------------
   flag[i] = false; //flag값을 false로 바꿔 임계 구역 사용 완료를 알림
   ```

3. **제과점(Bakery) 알고리즘**

   - 여러 프로세스/스레드에 대한 처리가 가능한 알고리즘. 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입

   ```c++
   while(1){
       isReady[i] = true; //번호표 받을 준비
       number[i] = max(number[0~n-1]) + 1; //현재 실행 중인 프로세스 중 가장 큰 번호 배정
       isReady[i] = false; //번호표 수령 완료
       
       for(j = 0; j < n; j++){ //모든 프로세스 번호표 비교
           while(isReady[j]); //비교 프로세스가 번호표 받을 때 까지 대기
           while(number[j] && number[j] < number[i] && j<i);
           //프로세스 j가 번호표를 가지고 있어야 함
           //프로세스 j의 번호표 < 프로세스 i의 번호표
       }
   }
   // ----------임계 구역------------
   number[i] = 0; //임계 구역 사용 종료
   ```

   

