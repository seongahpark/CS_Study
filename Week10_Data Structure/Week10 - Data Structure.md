# Week 10 - Data Structure

[출처 : gyoogle](https://gyoogle.dev/blog/computer-science/data-structure/Tree.html)

### 목차

[1. 트리 (Tree)](#트리-(Tree))

[2. 이진 탐색 트리](#이진-탐색-트리)

[3. 해시 (Hash)](해시-(Hash))

[4. 트라이 (Trie)](#트라이-(Trie))

[5. B Tree & B+ Tree](B-Tree-&-B+-Tree)

[6. 그래프 (Graph)](그래프-(Graph))

---

<br>

## 트리 (Tree)

> 값을 가진 Node와 노드를 연결해주는 Edge로 이루어진 자료구조
>
> 최상단의 노드를 **루트 노드**라 함
>
> 부모 - 자식 관계

![img](https://www.geeksforgeeks.org/wp-content/uploads/binary-tree-to-DLL.png)

- 특징
  - 사이클 존재 X (사이클이 만들어진다 -> 그래프)
  - 모든 노드는 자료형으로 표현 가능
  - 루트에서 한 노드로 가는 경로는 유일한 경로 뿐
  - 노드 개수가 N개면 간선의 개수는 N-1개



#### 트리 순회 방식

루트의 위치를 중심으로 이름이 지어진다고 이해하면 편하다.

1. **전위 순회 (Pre-order)**

   > 루트 -> 왼쪽 자식 -> 오른쪽 자식

2. **중위 순회 (In-order)**

   > 왼쪽 자식 -> 루트 -> 오른쪽 자식

3. **후위 순회 (Post-order)**

   > 왼쪽 자식 -> 오른쪽 자식 -> 루트

4. **레벨 순회 (Level-order)**

   > 루트부터 계층 별로 방문하는 형식

<br>

## 이진 탐색 트리 (Binary Search Tree)

> 이진탐색 + 연결리스트

이진탐색 : 탐색 시간 복잡도 **O(logN)**, 삽입 & 삭제 불가능

연결리스트 : 삽입, 삭제 시간복잡도 **O(1)**, 탐색 시간복잡도 O(N)

즉, 효율적인 탐색과 자료의 삽입 삭제를 가능하게 하기 위해 만든 자료구조

- 특징

  - 각 노드의 자식이 2개 이하

  - 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽은 부모보다 큼

  - 중복된 노드 허용 X

    > **중복이 없어야 하는 이유**
    >
    > 검색 목적 자료구조라 중복이 많으면 검색 속도가 느려짐
    >
    > 노드에 Count 값을 갖게하는 것이 더 효율적

  - **중위 순회** 방식으로 순회 (왼쪽 - 루트 - 오른쪽)

- 핵심 연산

  - 검색
  - 삽입
  - 삭제
  - 트리 생성
  - 트리 삭제

- 시간 복잡도 (노드 개수 N)

  - 균등 트리 : O(logN)
  - 편향 트리 : O(N)

  > 삽입, 검색, 삭제 시간복잡도는 트리의 **Depth**에 비례

- 삭제 Case

  1. 자식이 없는 leaf 노드일 때 -> 그냥 삭제
  2. 자식이 1개인 노드일 때 -> 지워진 노드에 자식 올림
  3. 자식이 2개인 노드일 때 -> 오른쪽 자식 노드에서 가장 작은 값 or 왼쪽 자식 노드에서 가장 큰 값 올리기



### 편향 이진 트리 개선 구조

정렬된 상태 값을 트리로 만들면 한쪽으로만 뻗는 편향된 트리가 생성된다.

시간복잡도가 O(N)이어서 비효율적. 이를 개선하기 위한 트리가 AVL, RedBlack Tree이다.

#### 1. AVL Tree

> 스스로 균형을 잡는 이진 탐색 트리

- 특징

  - 이진 탐색 트리 속성
  - 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1
  - 높이 차이가 1보다 커지면 회전을 통해 균형을 잡아 높이 차이를 줄임
  - 높이를 logN으로 유지하기 때문에 삽입/검색/삭제가 O(logN)

- Balance Factor (BF)

  > 왼쪽 서브트리 높이 - 오른쪽 서브트리의 높이
  >
  > -1 <= BF <= 1

  ![img](https://blog.kakaocdn.net/dn/blxsRD/btq21CW9Fw3/WOk8F74J254K1pczckskEK/img.png)

- 회전 (Rotation)

  - 불균형 노드를 기준으로 서브트리의 위치를 변경하여 균형을 맞춤

#### 2. RedBlack Tree

> 1. 모든 노드는 빨간색 or 검은색
> 2. 루트 노드는 검은색
> 3. Leaf 노드는 검은색
> 4. 빨간 노드의 자식은 모두 검은색. 검은색 노드의 자식은 빨강이 아니어도 됨
> 5. 루트 노드에서 모든 Leaf 노드 사이에 존재하는 검은색 노드의 수는 동일

- NIL 노드 : 아무 데이터도 가지고 있지 않지만, 색만 검은색인 더미 노드 -> 모든 Leaf 노드가 검은색인 것을 충족하기 위함
- 용도 : 연관 배열을 구현하는데 사용. 키 - 값으로 키를 통해 값을 얻을 수 있음
- Java에서 treeSet, treeMap이 RedBlack Tree 기반



#### AVL vs RedBlack

- 균형 잡힌 정도 : AVL이 더 우세
- 삽입 삭제 회전 정도 : Red Black의 회전 횟수가 적음
- 삽입 삭제가 자주 발생 -> Red Black
- 삽입 삭제가 적고 검색 빈도가 높다 -> AVL
- Red Black은 맵, C++ 멀티캐스트, Java treeMap
- AVL은 빠른 검색이 필요한 데이터베이스에서 사용



<br>

## 해시 (Hash)

> 임의의 길이 데이터를 고정된 길이의 데이터로 매핑

- 장점
  - 적은 자원으로 많은 데이터를 효율적으로 관리 가능 (ex. 하드디스크, 클라우드의 무한한 데이터를 유한한 개수의 해시값으로 매핑 -> 적은 메모리로도 프로세스 관리 가능)
  - 언제나 동일한 해시값 리턴 -> 빠른 데이터 검색 가능
  - 시간 복잡도 O(1)



#### Collision 현상

- 데이터가 많아지면 다른 데이터가 같은 해시 값으로 충돌
- 충돌 문제 해결
  1. **체이닝** : 연결리스트 노드를 계속 추가, 제한 X, 메모리 문제 O
  2. **Open Addressing** : 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장하도록 허용
  3. **선형 탐사** : 정해진 고정 폭으로 옮겨 중복 피함
  4. **제곱 탐사** : 정해진 고정 폭을 제곱수로 옮겨 중복 피함

<br>

## 트라이 (Trie)

> 문자열 검색을 빠르게 도와줌
>
> 문자열 최대 길이 M -> O(M)으로 문자열 검색 가능
>
> (문자열에서 이진탐색트리 사용시 O(M*logN))

![img](https://t1.daumcdn.net/cfile/tistory/24354E335833A7CF17)

<br>

## B Tree & B+ Tree

#### B Tree

> 이진 트리를 확장해 더 많은 수의 자식을 가질 수 있게 함

- 특징
  - 데이터베이스, 파일 시스템에서 사용
  - 자식 수에 대한 일반화 진행, 하나의 레벨에 더 저장
  - 트리의 균형을 자동으로 맞춤
  - 단순하고 효율적, 완전히 균형을 맞춘 트리
- 규칙
  - 노드의 자료수가 N개일 때, 자식 수는 N+1
  - 각 노드의 자료는 정렬된 상태
  - 루트 노드는 적어도 2개 이상의 자식을 가짐
  - 최대 M개의 자식을 가질 수 있는 경우, 루트 노드를 제외한 모든 노드는 적어도 M/2개의 자료를 가짐
  - 외부 노드로 가는 경로의 길이는 모두 같음
  - 입력 자료는 중복 X

<br>

## 그래프 (Graph)

> 값을 가진 Node와 노드를 연결해주는 Edge로 이루어진 자료구조
>
> 최상단의 노드를 **루트 노드**라 함
