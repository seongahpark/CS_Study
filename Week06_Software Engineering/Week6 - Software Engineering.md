# Week6 - Software Engineering

[출처 : gyoogle](https://gyoogle.dev/blog/computer-science/software-engineering/Object-Oriented%20Programming.html)

#### 목차

[1. 객체 지향 프로그래밍](#객체-지향-프로그래밍)

[2. 함수형 프로그래밍](#함수형-프로그래밍)



---

<br>

## 객체 지향 프로그래밍

1. **순차적, 비구조적 프로그래밍**

   필요한 게 있으면 순서대로 추가해가며 구현하는 방식

   **goto문** 활용 -> 무분별한 goto문은 코드의 흐름을 이해하는 데 시간을 소비할 가능성이 큼

   

2. **절차적, 구조적 프로그래밍**

   반복될 가능성이 있는 것들을 재사용이 가능한 **함수(프로시저)**로 만들어 사용

   절차는 함수를 뜻하고, 구조는 모듈을 뜻함

   > **프로시저**
   >
   > 반환값(리턴)이 존재하지 않는 함수 ex) 화면에 출력할 용도로 쓰이는 printf 함수
   >
   > *정확히 말하면 printf는 int형을 리턴해주긴 하지만 목적 자체는 프로시저에 가깝다*

   문제점은 자료형과 함수가 물리적으로 같이 있을 수 있지만 논리적으로 함께할 수 없는 구조이기 때문에 구분하기 힘들고 비효율적일 가능성이 높음

   

3. **객체지향 프로그래밍**

   **특정한 개념의 함수와 자료형을 함께 묶어서 관리하기 위해 탄생**

   객체 내부에 **자료형(필드)**와 **함수(메소드)**가 같이 존재

   객체 간의 독립성이 생기고 중복코드 양이 줄어들어 유지보수에 좋다

- **객체지향 프로그래밍의 특징**

  > **1. 추상화 (Abstraction)** : 필요로 하는 속성이나 행동을 추출하여 하나의 집합으로 만듦
  >
  > ​	추상화의 장점은 추가로 만들 부분만 새로 생성하면 되는 것으로 유지보수가 편리하다
  >
  > 
  >
  > **2. 캡슐화 (Encapsulation)** : 한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시	켜 낮은 결합도를 유지할 수 있도록 설계
  >
  > ​	```결합도는 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타냄```
  >
  > ​	**정보 은닉**을 활용하여 높은 응집도와 낮은 결합도를 갖게 함 -> 외부에서 접근할 필요가 없	는 것들은 private으로 제한을 둔다
  >
  > 
  >
  > **3. 상속 (Generalization)** : 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법	칙으로 성립
  >
  > ​	**자식 클래스를 외부로부터 은닉하는 캡슐화의 일종**
  >
  > ​	**※ 상속 재사용의 단점**
  >
  > - 상위 클래스(부모 클래스)의 변경이 어려워진다 : 의존하는 자식 클래스들까지 영향을 받기 때문
  >
  > - 불필요한 클래스가 증가할 수 있다 : 유사기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 할 수 도 있다
  >
  > - 상속이 잘못 사용될 수 있다 : 상속 받는 클래스가 부모 클래스와 IS-A 관계가 아닐 때 해당
  >
  >   > **IS-A** : 클래스 A가 다른 클래스 B의 파생클래스(상속)임을 말함. ex) 사과는 과일이다
  >   >
  >   > **HAS-A** : 상속이 아닌 일반적인 포함 개념의 관계. A가 B를 가지고 있음. ex) 차는 바퀴를 가지고 있다
  >
  > - **해결책** : 객체 조립을 적용한다. 상속에 비해 런타임 구조가 복잡해지고, 구현이 어려운 단점이 있지만, 변경 시 유연함을 확보하는데 장점이 크다
  >
  >   ``객체 조립 (Composition)``은 **필드에서 다른 객체를 참조하는 방식으로 구현**
  >
  > - **상속을 사용하는 경우** : ``IS-A 관계``가 성립, 재사용의 관점이 아닌 기능의 ``확장`` 관점일 때
  >
  > **4. 다형성 (Polymorphism)** : 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력 -> 코드를 간결하게 해주고 유연함을 갖추게 함
  >
  > ​	**부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용**
  >
  > > ※ **오버로딩 & 오버라이딩**
  > >
  > > - **오버로딩 (Overloading)** : 같은 이름의 메소드를 여러개를 가지면서 매개변수의 유형과 개수에 따라 다르게 동적하는 기술
  > > - **오버 라이딩 (Overriding)** : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용 (부모와 자식의 메소드 이름이 같고, 매개변수가 같고, 반환형이 같을 때 자식 클래스의 메소드 기능을 사용함)

- **객체 지향 설계 과정**

  > - 제공해야 할 기능을 찾고 세분화하여 알맞은 객체에 할당한다
  > - 기능을 구현하는데 필요한 데이터를 객체에 추가한다
  > - 데이터를 이용하는 기능을 넣는다
  > - 기능은 최대한 캡슐화하여 구현한다
  > - 객체 간 어떻게 메소드 요청을 주고받을 지 결정한다

- **객체 지향 설계 원칙 (SOLID)** 

  > 1. **SRP (Single Responsibility)** : 단일 책임 원칙, 클래스를 변경하는 이유는 단 한개
  > 2. **OCP (Open-Closed)** : 개방-폐쇄 원칙, 확장에는 열려있고, 수정에는 닫힘
  > 3. **LSP (Liskov Substitution)** : 리스코프 치환 원칙, 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 작동
  > 4. **ISP (Interface Segregation)** : 인터페이스 분리 원칙, 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리. 사용하지 않는 인터페이스에 변경이 생겨도 영향을 받지 않아야 함
  > 5. **DIP (Dependency Inversion)** : 의존 역전 원칙, 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안됨. 저수준 모듈이 변경돼도 고수준 모듈은 변경할 필요가 없어야 함

<br>

---

<br>

## 함수형 프로그래밍

> 부수효과를 없애고 순수 함수를 만들어 모듈화 수준을 높이는 프로그래밍 패러다임



<img src="https://user-images.githubusercontent.com/6733004/46247710-5ce5fb00-c44a-11e8-9400-16dd44626820.png" alt="img" style="zoom:80%;" />

<div align="center">사진은 빼먹으면 섭섭할 것 같아서 넣었다.</div>

1. **명령형 프로그래밍 VS 선언형 프로그래밍**

   >- **명령형 프로그래밍 (절차지향, 객체지향)**
   >
   >  > 상태와 상태를 변경시키는 관점에서 연산을 설명하는 방식 (How)
   >  >
   >  > 알고리즘을 명시, 목표는 명시 X
   >
   >- **선언형 프로그래밍**
   >
   >  > How 보다는 What을 설명하는 방식
   >  >
   >  > 알고리즘 명시 X, 목표만 명시

   함수형 코드는 명령형 프로그래밍보다 더 간결하고 예측가능하여 테스트가 쉽다

   즉, 함수형 프로그램은 ``부작용을 제거하여 프로그램의 동작을 이해하고 예측을 용이``하게 한다

   프로그래밍 언어나 방식을 배우기 보다는 함수형 프로그래밍 사고를 배우는 것

   단, 익숙치 않으면 더 복잡해보이고 이해하기 어렵다

   

2. **함수형 프로그래밍**

   - 순수 함수 (Pure Functions) : 입출력이 순수, 반드시 하나 이상의 인자를 받고, 받은 인자를 처리해 반드시 결과를 돌려줘야 함. 인자 외 다른 변수는 사용 X
   - 합성 함수 (Function Composition) : 새로운 함수를 만들어내거나 계산하기 위해 둘 이상의 함수를 조합하는 과정. 여러 작은 순수 함수들을 연쇄적 또는 병렬로 호출하여 더 큰 함수로 만듦
   - 공유상태 피하기 (Avoid Shared State)
   - 상태변화 피하기 (Avoid Mutating State)
   - 부작용 피하기 (Avoid Side Effects) : 원본 데이터는 절대 불변

   > **부수 효과 (Side Effect) ** : 주어진 값 이외의 외부 변수 및 프로그래밍 실행에 영향을 끼침
   >
   > - 변수의 값이 변경
   > - 자료 구조를 제자리에서 수정
   > - 객체의 필드값을 설정
   > - 예외나 오류가 발생하여 실행이 중단
   > - 콘솔 또는 파일 I/O가 발생

   대표적인 자바 스크립트 함수형 프로그래밍 함수 : ``map``, ``filter``, ``reduce``

   

3. **Java에서의 함수형 프로그래밍**

   - Java 8이 릴리즈되면서 함수형 프로그래밍이 가능
   - Java에서 활용할 수 있는 함수형 프로그래밍 : ``람다식``, ``stream api``, ``함수형 인터페이스``

   ```java
   import java.util.Arrays;
   improt java.util.List;
   
   public class stream{
       public static void main(Strings[] args){
           List<String> myList = Array.asList("a", "b", "c", "d", "e");
           
           //기존 방식
           for(int i=0; i<myList.size(); i++){
               String s = myList.get(i);
               if(s.startsWith("c")){
                   System.out.println(s.toUpperCase());
               }
           }
           
           //stream API를 이용
           myList.stream()
               .filter(s -> s.startswith("c"))
               .map(String::toUpperCse)
               .forEach(System.out::println);
       }
   }
   ```

   함수형 프로그래밍으로 내가 무엇을 구현했는지 직관적으로 명확히 알 수 있다.

   

4. **C++에서의 함수형 프로그래밍** (게임개발 측면)

   >기본적으로 C++, C# 등의 언어는 객체지향 언어이다.
   >
   >함수형 프로그래밍 패러다임을 적용하려면 다 작은 함수로 쪼개서 만들어 합쳐서 개발하는 것이다.
   >
   >실제로 현업에서도 유행하는 패러다임이라고 한다

   ```C++
   private static bool isAlive = true;
   
   private bool chkHp(int _hp){
       if(_hp < 0) isAlive = false;
       return isAlive;
   }
   ```

   

---

### 추가 내용

[출처](https://zuyo.tistory.com/891)

#### 업 캐스팅 (Upcasting)

> 서브 클래스는 슈퍼 클래스의 모든 특성을 상속 받는다. 즉, **서브 클래스가 슈퍼클래스가 되는 것이 업 캐스팅이다**.
>
> 업캐스팅시 자식클래스의 멤버는 접근이 불가해지고, 부모클래스의 멤버만 사용 가능하다.
>
> 그러나, 자식클래스가 부모클래스의 메소드를 오버라이딩 했다면, 오버라이딩 된 자식클래스의 메소드가 호출된다.

```java
class Person{ //슈퍼클래스
	String name;
	String id;
	
	public Person(String name){
		this.name = name;
	}
}

class Student extends Person{ //서브클래스
	String grade;
	
	public Student(String name){
        super(name);
    }
    public Student(String name, String grade){
        super(name);
        this.grade = grade;
    }
}

public class Example{
    public static void main(String[] args){
        Person person;
        Student student = new Student("학생");
        person = student; //업캐스팅
        
        System.out.printpln(person.name);
        person.grade = "A"; // 에러 -> 서브클래스 Student의 멤버 grade에 접근 X
    }
}
```



#### 다운 캐스팅 (DownCasting)

> 서브 클래스가 슈퍼 클래스로 변했을 때 서브 클래스의 인스턴스는 잠시 가려져 있을 뿐, 사라지지 않는다. **서브 클래스의 원래 특성으로 돌려놓는게 다운 캐스팅**.
>
> 다운 캐스팅은 업 캐스팅과 달리 명시적으로 타입을 지정해야 함. (강제형변환)

```java
public class Example{
    public static void main(String[] args){
        Person person = new Student("학생"); // 업캐스팅
        
        Student student = (Student)person; //다운캐스팅
        
        System.out.println(student.name);
        student.grade = "A"; // 서브클래스의 멤버에 접근이 가능
    }
}
```



#### Instance Of 연산자

객체가 어떤 클래스 타입인지 알려주는 연산자. 업캐스팅 된 객체라도 true를 반환한다.

**형태** : 결과 값은 boolean

> **[객체 레퍼런스] instanceof [클래스 타입]**

```java
if(person instanceof Person){
	System.out.println("사람이 맞다");
}
```



#### 메소드 시그니처

자바 컴파일러는 **메소드의 이름**과 **파라미터**를 이용하여 메소드 구분

이 메소드 이름과 파라미터를 **메소드 시그니처**라고 함

단, 리턴타입은 메소드 시그니처에 포함X -> 서로 다른 리턴 타입을 가져도 동일한 시그니처를 가진 2개의 메소드 선언 X



#### 네임 맹글링 (네임 데코레이션)

> 선언시 사용했던 이름을 컴파일러가 컴파일 단계에서 일정한 규칙을 가지고 변형하는 것
>
> 같은 이름의 함수 및 변수를 구별하게 해줌
>
> 사용하는 컴파일러와 언어마다 방법이 다르다
